<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.67">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>IO多路复用 | zzys</title><meta name="description" content="zzys的个人博客">
    <link rel="preload" href="/assets/style-ec18e87d.css" as="style"><link rel="stylesheet" href="/assets/style-ec18e87d.css">
    <link rel="modulepreload" href="/assets/app-20538318.js"><link rel="modulepreload" href="/assets/IO多路复用.html-4458e9c4.js"><link rel="modulepreload" href="/assets/IO多路复用.html-b72a10af.js"><link rel="prefetch" href="/assets/index.html-1124f69b.js" as="script"><link rel="prefetch" href="/assets/index.html-b5ca648f.js" as="script"><link rel="prefetch" href="/assets/JUC.html-b947128f.js" as="script"><link rel="prefetch" href="/assets/Java.html-e71f1d55.js" as="script"><link rel="prefetch" href="/assets/index.html-bec769cf.js" as="script"><link rel="prefetch" href="/assets/Redis.html-db0c73b7.js" as="script"><link rel="prefetch" href="/assets/algorithm.html-e08339d8.js" as="script"><link rel="prefetch" href="/assets/mysql.html-6397606b.js" as="script"><link rel="prefetch" href="/assets/network.html-4f45418e.js" as="script"><link rel="prefetch" href="/assets/spring.html-cda4aba9.js" as="script"><link rel="prefetch" href="/assets/sundry.html-fffeb8dd.js" as="script"><link rel="prefetch" href="/assets/markdown.html-da1a35cd.js" as="script"><link rel="prefetch" href="/assets/mermaid使用.html-3fbe0211.js" as="script"><link rel="prefetch" href="/assets/how-to-learn.html-5b83d000.js" as="script"><link rel="prefetch" href="/assets/DFS、BFS.html-0152ce7c.js" as="script"><link rel="prefetch" href="/assets/KMP、Trie.html-dc92ba21.js" as="script"><link rel="prefetch" href="/assets/二分问题.html-aac3900c.js" as="script"><link rel="prefetch" href="/assets/位运算、离散化、区间合并.html-95650150.js" as="script"><link rel="prefetch" href="/assets/前缀和.html-13bb620c.js" as="script"><link rel="prefetch" href="/assets/双指针.html-93090f76.js" as="script"><link rel="prefetch" href="/assets/堆、哈希.html-241abe1d.js" as="script"><link rel="prefetch" href="/assets/差分.html-b7e4cfd1.js" as="script"><link rel="prefetch" href="/assets/index.html-e5a6ceab.js" as="script"><link rel="prefetch" href="/assets/kernel-bypass.html-facea451.js" as="script"><link rel="prefetch" href="/assets/kernel-user-buffer.html-f9361e59.js" as="script"><link rel="prefetch" href="/assets/page-cache.html-682e229c.js" as="script"><link rel="prefetch" href="/assets/零拷贝.html-cf38ad35.js" as="script"><link rel="prefetch" href="/assets/InnoDB存储引擎.html-70e01e32.js" as="script"><link rel="prefetch" href="/assets/事务.html-d355871a.js" as="script"><link rel="prefetch" href="/assets/索引.html-d48460b1.js" as="script"><link rel="prefetch" href="/assets/锁.html-290c3d9a.js" as="script"><link rel="prefetch" href="/assets/COW-写时复制.html-607e38a6.js" as="script"><link rel="prefetch" href="/assets/snowflakeid.html-891ca13d.js" as="script"><link rel="prefetch" href="/assets/两阶段提交.html-f1cd283a.js" as="script"><link rel="prefetch" href="/assets/分布式锁.html-dbe6fb5f.js" as="script"><link rel="prefetch" href="/assets/幂等.html-52411ecf.js" as="script"><link rel="prefetch" href="/assets/秒杀场景.html-632fc29c.js" as="script"><link rel="prefetch" href="/assets/限流.html-140ddd4d.js" as="script"><link rel="prefetch" href="/assets/Golang-万声音乐-实习-23-12-27.html-28b6bfe4.js" as="script"><link rel="prefetch" href="/assets/Golang-百度-实习-23-12-11.html-049f9e2c.js" as="script"><link rel="prefetch" href="/assets/Java-喜马拉雅-实习-23-8-21.html-065a1c40.js" as="script"><link rel="prefetch" href="/assets/Java-数新网络-实习-23-12-07.html-cacab6ef.js" as="script"><link rel="prefetch" href="/assets/go.html-fd549940.js" as="script"><link rel="prefetch" href="/assets/java.html-94772974.js" as="script"><link rel="prefetch" href="/assets/index.html-2bac24fc.js" as="script"><link rel="prefetch" href="/assets/数据库表设计.html-155d4faa.js" as="script"><link rel="prefetch" href="/assets/测试.html-b1b1df80.js" as="script"><link rel="prefetch" href="/assets/组件开发.html-3811c884.js" as="script"><link rel="prefetch" href="/assets/项目准备.html-19019ac3.js" as="script"><link rel="prefetch" href="/assets/AOP.html-08519e3c.js" as="script"><link rel="prefetch" href="/assets/IOC.html-bbb032df.js" as="script"><link rel="prefetch" href="/assets/JdbcTemplate-Transaction.html-45ebad5a.js" as="script"><link rel="prefetch" href="/assets/MVC.html-217b44a6.js" as="script"><link rel="prefetch" href="/assets/DP.html-40b096d3.js" as="script"><link rel="prefetch" href="/assets/线性DP.html-6abac9c1.js" as="script"><link rel="prefetch" href="/assets/背包问题.html-f78447ad.js" as="script"><link rel="prefetch" href="/assets/归并排序.html-1acadf46.js" as="script"><link rel="prefetch" href="/assets/快速排序.html-09eb791d.js" as="script"><link rel="prefetch" href="/assets/单链表和双链表的数组实现.html-bf919e6d.js" as="script"><link rel="prefetch" href="/assets/并查集.html-66337019.js" as="script"><link rel="prefetch" href="/assets/栈和队列.html-77c4e30b.js" as="script"><link rel="prefetch" href="/assets/树状数组和线段树.html-5a392d61.js" as="script"><link rel="prefetch" href="/assets/图相关的基本算法.html-3374d688.js" as="script"><link rel="prefetch" href="/assets/树、图的存储和遍历.html-7dfcf155.js" as="script"><link rel="prefetch" href="/assets/DesignPattern.html-d1e8d094.js" as="script"><link rel="prefetch" href="/assets/builder.html-30f560af.js" as="script"><link rel="prefetch" href="/assets/chain.html-ed1b2acb.js" as="script"><link rel="prefetch" href="/assets/strategy.html-1d5899e0.js" as="script"><link rel="prefetch" href="/assets/golang-plugin.html-47c8f36c.js" as="script"><link rel="prefetch" href="/assets/golang基础入门.html-afaf7ee0.js" as="script"><link rel="prefetch" href="/assets/index.html-d0dd1a10.js" as="script"><link rel="prefetch" href="/assets/SPI.html-8a3365b2.js" as="script"><link rel="prefetch" href="/assets/jvm.html-e270154b.js" as="script"><link rel="prefetch" href="/assets/ruoyi-vue启动配置.html-90198d7b.js" as="script"><link rel="prefetch" href="/assets/redis使用场景.html-34c00e53.js" as="script"><link rel="prefetch" href="/assets/redis持久化.html-bfc1cefc.js" as="script"><link rel="prefetch" href="/assets/rust入门01-基础配置.html-e34a4fb6.js" as="script"><link rel="prefetch" href="/assets/springboot发布订阅机制.html-5175d1fa.js" as="script"><link rel="prefetch" href="/assets/动手写starter.html-c60b47b8.js" as="script"><link rel="prefetch" href="/assets/自定义spring-cloud-gateway-filter.html-d11e8c8b.js" as="script"><link rel="prefetch" href="/assets/非spring管理的类使用bean.html-9680c239.js" as="script"><link rel="prefetch" href="/assets/C编程杂记.html-ff5c1519.js" as="script"><link rel="prefetch" href="/assets/Makefile.html-7a575781.js" as="script"><link rel="prefetch" href="/assets/risc-v.html-abe15f5f.js" as="script"><link rel="prefetch" href="/assets/computer-summary.html-39fac1ff.js" as="script"><link rel="prefetch" href="/assets/system-bus.html-17a5cf43.js" as="script"><link rel="prefetch" href="/assets/汇编下的函数调用.html-57a70b1c.js" as="script"><link rel="prefetch" href="/assets/csapp-信息的表示和处理.html-90b44a6a.js" as="script"><link rel="prefetch" href="/assets/csapp-程序的机器级表示(1).html-340c19c9.js" as="script"><link rel="prefetch" href="/assets/csapp-程序的机器级表示(2).html-31014b89.js" as="script"><link rel="prefetch" href="/assets/network-ttd-application.html-e80964b6.js" as="script"><link rel="prefetch" href="/assets/network-ttd-summary.html-caf53cba.js" as="script"><link rel="prefetch" href="/assets/snmp-Java.html-c909064d.js" as="script"><link rel="prefetch" href="/assets/snmp压力测试.html-39568e54.js" as="script"><link rel="prefetch" href="/assets/ostep-concurrency.html-6d1ea898.js" as="script"><link rel="prefetch" href="/assets/ostep-persistence.html-09c90a2a.js" as="script"><link rel="prefetch" href="/assets/ostep-virtualization-cpu.html-d1249a4e.js" as="script"><link rel="prefetch" href="/assets/ostep-virtualization-memory.html-b89f52b2.js" as="script"><link rel="prefetch" href="/assets/CPU缓存一致性.html-4f7e276a.js" as="script"><link rel="prefetch" href="/assets/关于提问.html-d1087a4f.js" as="script"><link rel="prefetch" href="/assets/Backup-VMware.html-7c28803d.js" as="script"><link rel="prefetch" href="/assets/Frangipani.html-efd69a09.js" as="script"><link rel="prefetch" href="/assets/GFS.html-c0190339.js" as="script"><link rel="prefetch" href="/assets/Introduction-MapReduce.html-6d51a2e9.js" as="script"><link rel="prefetch" href="/assets/index.html-5b815926.js" as="script"><link rel="prefetch" href="/assets/Spanner.html-b14643bf.js" as="script"><link rel="prefetch" href="/assets/Zookeeper.html-70da7092.js" as="script"><link rel="prefetch" href="/assets/分布式事务.html-5b0c0d47.js" as="script"><link rel="prefetch" href="/assets/链式复制.html-89fe6b95.js" as="script"><link rel="prefetch" href="/assets/Angular基础入门.html-9caaa6fe.js" as="script"><link rel="prefetch" href="/assets/Angular环境配置和基础认知.html-64107121.js" as="script"><link rel="prefetch" href="/assets/ES6-01 let和const.html-ff066299.js" as="script"><link rel="prefetch" href="/assets/ES6-02 解构赋值.html-d71d95a8.js" as="script"><link rel="prefetch" href="/assets/ES6-03 class.html-a18531b4.js" as="script"><link rel="prefetch" href="/assets/ES6-04 ES6新增用法.html-44208019.js" as="script"><link rel="prefetch" href="/assets/ES6-05 Symbol.html-60bc338b.js" as="script"><link rel="prefetch" href="/assets/ES6-06 Module的导入和导出.html-b047a5c9.js" as="script"><link rel="prefetch" href="/assets/最长系列.html-ae919bcf.js" as="script"><link rel="prefetch" href="/assets/反转链表.html-71d96c63.js" as="script"><link rel="prefetch" href="/assets/合并链表.html-7e16bf84.js" as="script"><link rel="prefetch" href="/assets/数的二次方根.html-09e9cc4d.js" as="script"><link rel="prefetch" href="/assets/组合.html-2eea3f6d.js" as="script"><link rel="prefetch" href="/assets/ebpf杂记.html-ef72f24c.js" as="script"><link rel="prefetch" href="/assets/支付服务.html-a1d43d44.js" as="script"><link rel="prefetch" href="/assets/用户服务.html-f9de0dca.js" as="script"><link rel="prefetch" href="/assets/票务服务.html-8a828469.js" as="script"><link rel="prefetch" href="/assets/订单服务.html-a9509189.js" as="script"><link rel="prefetch" href="/assets/Redis.html-d7c24a25.js" as="script"><link rel="prefetch" href="/assets/RocketMq.html-a2e7cc56.js" as="script"><link rel="prefetch" href="/assets/go-zero入门实践.html-3ac3732f.js" as="script"><link rel="prefetch" href="/assets/Basic.html-394238ab.js" as="script"><link rel="prefetch" href="/assets/Collction.html-8f5a4579.js" as="script"><link rel="prefetch" href="/assets/JDK动态代理.html-558bcf44.js" as="script"><link rel="prefetch" href="/assets/ThreadLocal.html-56b3c13b.js" as="script"><link rel="prefetch" href="/assets/enum.html-a0d9e8a9.js" as="script"><link rel="prefetch" href="/assets/this与super.html-dfcab97c.js" as="script"><link rel="prefetch" href="/assets/方法调用.html-8663b59b.js" as="script"><link rel="prefetch" href="/assets/泛型.html-a3b1e955.js" as="script"><link rel="prefetch" href="/assets/juc.html-aca7fee8.js" as="script"><link rel="prefetch" href="/assets/快速消费线程池.html-b751f9c8.js" as="script"><link rel="prefetch" href="/assets/summary-question.html-7bbf36ce.js" as="script"><link rel="prefetch" href="/assets/MapReduce.html-cbf2c0fd.js" as="script"><link rel="prefetch" href="/assets/404.html-5b1f7f3d.js" as="script"><link rel="prefetch" href="/assets/index.html-44996371.js" as="script"><link rel="prefetch" href="/assets/index.html-e92be3ae.js" as="script"><link rel="prefetch" href="/assets/JUC.html-887c05ff.js" as="script"><link rel="prefetch" href="/assets/Java.html-7b4b17b6.js" as="script"><link rel="prefetch" href="/assets/index.html-5984488a.js" as="script"><link rel="prefetch" href="/assets/Redis.html-2b56049a.js" as="script"><link rel="prefetch" href="/assets/algorithm.html-df207cf9.js" as="script"><link rel="prefetch" href="/assets/mysql.html-b4d641c4.js" as="script"><link rel="prefetch" href="/assets/network.html-9767e8ee.js" as="script"><link rel="prefetch" href="/assets/spring.html-296cbbd8.js" as="script"><link rel="prefetch" href="/assets/sundry.html-06734938.js" as="script"><link rel="prefetch" href="/assets/markdown.html-ef1eae30.js" as="script"><link rel="prefetch" href="/assets/mermaid使用.html-ce9d6f43.js" as="script"><link rel="prefetch" href="/assets/how-to-learn.html-73c08c01.js" as="script"><link rel="prefetch" href="/assets/DFS、BFS.html-e1fbd187.js" as="script"><link rel="prefetch" href="/assets/KMP、Trie.html-d811b3aa.js" as="script"><link rel="prefetch" href="/assets/二分问题.html-264c5765.js" as="script"><link rel="prefetch" href="/assets/位运算、离散化、区间合并.html-a9ddee85.js" as="script"><link rel="prefetch" href="/assets/前缀和.html-c20ad3d5.js" as="script"><link rel="prefetch" href="/assets/双指针.html-0a61aa72.js" as="script"><link rel="prefetch" href="/assets/堆、哈希.html-69306e0d.js" as="script"><link rel="prefetch" href="/assets/差分.html-b1a92e71.js" as="script"><link rel="prefetch" href="/assets/index.html-2908654b.js" as="script"><link rel="prefetch" href="/assets/kernel-bypass.html-ee662e08.js" as="script"><link rel="prefetch" href="/assets/kernel-user-buffer.html-40efe7f2.js" as="script"><link rel="prefetch" href="/assets/page-cache.html-42117d5d.js" as="script"><link rel="prefetch" href="/assets/零拷贝.html-db16c5d0.js" as="script"><link rel="prefetch" href="/assets/InnoDB存储引擎.html-8f0cb0cc.js" as="script"><link rel="prefetch" href="/assets/事务.html-292f44da.js" as="script"><link rel="prefetch" href="/assets/索引.html-f95e279e.js" as="script"><link rel="prefetch" href="/assets/锁.html-6fdabc58.js" as="script"><link rel="prefetch" href="/assets/COW-写时复制.html-121aff84.js" as="script"><link rel="prefetch" href="/assets/snowflakeid.html-f89b7bc0.js" as="script"><link rel="prefetch" href="/assets/两阶段提交.html-35cb4496.js" as="script"><link rel="prefetch" href="/assets/分布式锁.html-ddfe53c1.js" as="script"><link rel="prefetch" href="/assets/幂等.html-0c9f98a2.js" as="script"><link rel="prefetch" href="/assets/秒杀场景.html-54be4769.js" as="script"><link rel="prefetch" href="/assets/限流.html-c9e4b631.js" as="script"><link rel="prefetch" href="/assets/Golang-万声音乐-实习-23-12-27.html-3a5dfd57.js" as="script"><link rel="prefetch" href="/assets/Golang-百度-实习-23-12-11.html-9207187e.js" as="script"><link rel="prefetch" href="/assets/Java-喜马拉雅-实习-23-8-21.html-6b0ebc76.js" as="script"><link rel="prefetch" href="/assets/Java-数新网络-实习-23-12-07.html-3c624790.js" as="script"><link rel="prefetch" href="/assets/go.html-735e06ad.js" as="script"><link rel="prefetch" href="/assets/java.html-0f80f749.js" as="script"><link rel="prefetch" href="/assets/index.html-a51412db.js" as="script"><link rel="prefetch" href="/assets/数据库表设计.html-fc478905.js" as="script"><link rel="prefetch" href="/assets/测试.html-0c7ea1c7.js" as="script"><link rel="prefetch" href="/assets/组件开发.html-4ec7407e.js" as="script"><link rel="prefetch" href="/assets/项目准备.html-36949014.js" as="script"><link rel="prefetch" href="/assets/AOP.html-99152493.js" as="script"><link rel="prefetch" href="/assets/IOC.html-40d81f53.js" as="script"><link rel="prefetch" href="/assets/JdbcTemplate-Transaction.html-01a0af06.js" as="script"><link rel="prefetch" href="/assets/MVC.html-321cb134.js" as="script"><link rel="prefetch" href="/assets/DP.html-cdf50853.js" as="script"><link rel="prefetch" href="/assets/线性DP.html-c5df8114.js" as="script"><link rel="prefetch" href="/assets/背包问题.html-47b19b73.js" as="script"><link rel="prefetch" href="/assets/归并排序.html-ae6b3c3c.js" as="script"><link rel="prefetch" href="/assets/快速排序.html-6e652588.js" as="script"><link rel="prefetch" href="/assets/单链表和双链表的数组实现.html-adf0dc04.js" as="script"><link rel="prefetch" href="/assets/并查集.html-81d14406.js" as="script"><link rel="prefetch" href="/assets/栈和队列.html-fdee587b.js" as="script"><link rel="prefetch" href="/assets/树状数组和线段树.html-50a99469.js" as="script"><link rel="prefetch" href="/assets/图相关的基本算法.html-45524102.js" as="script"><link rel="prefetch" href="/assets/树、图的存储和遍历.html-c9c461ed.js" as="script"><link rel="prefetch" href="/assets/DesignPattern.html-ad290a7e.js" as="script"><link rel="prefetch" href="/assets/builder.html-cd91d61c.js" as="script"><link rel="prefetch" href="/assets/chain.html-cb0459b3.js" as="script"><link rel="prefetch" href="/assets/strategy.html-8bd3ed4f.js" as="script"><link rel="prefetch" href="/assets/golang-plugin.html-5452c2fe.js" as="script"><link rel="prefetch" href="/assets/golang基础入门.html-58b3eb63.js" as="script"><link rel="prefetch" href="/assets/index.html-a48563f0.js" as="script"><link rel="prefetch" href="/assets/SPI.html-09d4bacf.js" as="script"><link rel="prefetch" href="/assets/jvm.html-c41a905a.js" as="script"><link rel="prefetch" href="/assets/ruoyi-vue启动配置.html-ea334c21.js" as="script"><link rel="prefetch" href="/assets/redis使用场景.html-bd17fc76.js" as="script"><link rel="prefetch" href="/assets/redis持久化.html-c9f95200.js" as="script"><link rel="prefetch" href="/assets/rust入门01-基础配置.html-f14caf72.js" as="script"><link rel="prefetch" href="/assets/springboot发布订阅机制.html-5493ce14.js" as="script"><link rel="prefetch" href="/assets/动手写starter.html-3798cc84.js" as="script"><link rel="prefetch" href="/assets/自定义spring-cloud-gateway-filter.html-79fe2e7f.js" as="script"><link rel="prefetch" href="/assets/非spring管理的类使用bean.html-4756608b.js" as="script"><link rel="prefetch" href="/assets/C编程杂记.html-af9b9a1d.js" as="script"><link rel="prefetch" href="/assets/Makefile.html-5b661539.js" as="script"><link rel="prefetch" href="/assets/risc-v.html-1fa0a9d6.js" as="script"><link rel="prefetch" href="/assets/computer-summary.html-15fdce20.js" as="script"><link rel="prefetch" href="/assets/system-bus.html-79150efb.js" as="script"><link rel="prefetch" href="/assets/汇编下的函数调用.html-ba2361f7.js" as="script"><link rel="prefetch" href="/assets/csapp-信息的表示和处理.html-bea84563.js" as="script"><link rel="prefetch" href="/assets/csapp-程序的机器级表示(1).html-7484a122.js" as="script"><link rel="prefetch" href="/assets/csapp-程序的机器级表示(2).html-eb2c994c.js" as="script"><link rel="prefetch" href="/assets/network-ttd-application.html-271c282f.js" as="script"><link rel="prefetch" href="/assets/network-ttd-summary.html-1b03357e.js" as="script"><link rel="prefetch" href="/assets/snmp-Java.html-cdbffdaa.js" as="script"><link rel="prefetch" href="/assets/snmp压力测试.html-c01bd76c.js" as="script"><link rel="prefetch" href="/assets/ostep-concurrency.html-7d636c94.js" as="script"><link rel="prefetch" href="/assets/ostep-persistence.html-ad5d2ed5.js" as="script"><link rel="prefetch" href="/assets/ostep-virtualization-cpu.html-b0003fe4.js" as="script"><link rel="prefetch" href="/assets/ostep-virtualization-memory.html-45ac2b89.js" as="script"><link rel="prefetch" href="/assets/CPU缓存一致性.html-27640a99.js" as="script"><link rel="prefetch" href="/assets/关于提问.html-4b09e8d8.js" as="script"><link rel="prefetch" href="/assets/Backup-VMware.html-a4c90ba2.js" as="script"><link rel="prefetch" href="/assets/Frangipani.html-3c2a116d.js" as="script"><link rel="prefetch" href="/assets/GFS.html-1d395bd2.js" as="script"><link rel="prefetch" href="/assets/Introduction-MapReduce.html-4d67b644.js" as="script"><link rel="prefetch" href="/assets/index.html-4a4fc4a1.js" as="script"><link rel="prefetch" href="/assets/Spanner.html-8c307be5.js" as="script"><link rel="prefetch" href="/assets/Zookeeper.html-088641ab.js" as="script"><link rel="prefetch" href="/assets/分布式事务.html-a5ce5ca6.js" as="script"><link rel="prefetch" href="/assets/链式复制.html-e4612b8d.js" as="script"><link rel="prefetch" href="/assets/Angular基础入门.html-c4760f33.js" as="script"><link rel="prefetch" href="/assets/Angular环境配置和基础认知.html-71fceb7a.js" as="script"><link rel="prefetch" href="/assets/ES6-01 let和const.html-4974fa52.js" as="script"><link rel="prefetch" href="/assets/ES6-02 解构赋值.html-c40bc963.js" as="script"><link rel="prefetch" href="/assets/ES6-03 class.html-282a0081.js" as="script"><link rel="prefetch" href="/assets/ES6-04 ES6新增用法.html-ccffdc43.js" as="script"><link rel="prefetch" href="/assets/ES6-05 Symbol.html-2b30945f.js" as="script"><link rel="prefetch" href="/assets/ES6-06 Module的导入和导出.html-376668d4.js" as="script"><link rel="prefetch" href="/assets/最长系列.html-4acc5e07.js" as="script"><link rel="prefetch" href="/assets/反转链表.html-3c5d4787.js" as="script"><link rel="prefetch" href="/assets/合并链表.html-22e7414b.js" as="script"><link rel="prefetch" href="/assets/数的二次方根.html-6c8f3083.js" as="script"><link rel="prefetch" href="/assets/组合.html-055d36a8.js" as="script"><link rel="prefetch" href="/assets/ebpf杂记.html-3442c502.js" as="script"><link rel="prefetch" href="/assets/支付服务.html-de1c5180.js" as="script"><link rel="prefetch" href="/assets/用户服务.html-2d79f898.js" as="script"><link rel="prefetch" href="/assets/票务服务.html-5bb57784.js" as="script"><link rel="prefetch" href="/assets/订单服务.html-adebf0ec.js" as="script"><link rel="prefetch" href="/assets/Redis.html-5fb3c285.js" as="script"><link rel="prefetch" href="/assets/RocketMq.html-2fb8ca8d.js" as="script"><link rel="prefetch" href="/assets/go-zero入门实践.html-946e17c3.js" as="script"><link rel="prefetch" href="/assets/Basic.html-255d7873.js" as="script"><link rel="prefetch" href="/assets/Collction.html-75d6ab2a.js" as="script"><link rel="prefetch" href="/assets/JDK动态代理.html-e70757de.js" as="script"><link rel="prefetch" href="/assets/ThreadLocal.html-5eef6bcc.js" as="script"><link rel="prefetch" href="/assets/enum.html-0a176866.js" as="script"><link rel="prefetch" href="/assets/this与super.html-71ee4784.js" as="script"><link rel="prefetch" href="/assets/方法调用.html-22c9acd5.js" as="script"><link rel="prefetch" href="/assets/泛型.html-df3f4983.js" as="script"><link rel="prefetch" href="/assets/juc.html-526b1ba3.js" as="script"><link rel="prefetch" href="/assets/快速消费线程池.html-0b35653f.js" as="script"><link rel="prefetch" href="/assets/summary-question.html-63b87c73.js" as="script"><link rel="prefetch" href="/assets/MapReduce.html-9c871870.js" as="script"><link rel="prefetch" href="/assets/404.html-4f169f81.js" as="script"><link rel="prefetch" href="/assets/mermaid.core-32c63708.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><span class="site-name">zzys</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/interview/" class="" aria-label="interview"><!--[--><!--]--> interview <!--[--><!--]--></a></div><div class="navbar-item"><a href="/code/" class="router-link-active" aria-label="code"><!--[--><!--]--> code <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/YangZhang-dev" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/interview/" class="" aria-label="interview"><!--[--><!--]--> interview <!--[--><!--]--></a></div><div class="navbar-item"><a href="/code/" class="router-link-active" aria-label="code"><!--[--><!--]--> code <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/YangZhang-dev" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading active collapsible">code <span class="down arrow"></span></p><ul style="" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">algorithm <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">dp <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/algorithm/dp/DP.html" class="sidebar-item" aria-label="DP问题"><!--[--><!--]--> DP问题 <!--[--><!--]--></a><!----></li><li><a href="/code/algorithm/dp/%E7%BA%BF%E6%80%A7DP.html" class="sidebar-item" aria-label="线性DP"><!--[--><!--]--> 线性DP <!--[--><!--]--></a><!----></li><li><a href="/code/algorithm/dp/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.html" class="sidebar-item" aria-label="背包问题"><!--[--><!--]--> 背包问题 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">排序 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/algorithm/%E6%8E%92%E5%BA%8F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.html" class="sidebar-item" aria-label="归并排序"><!--[--><!--]--> 归并排序 <!--[--><!--]--></a><!----></li><li><a href="/code/algorithm/%E6%8E%92%E5%BA%8F/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html" class="sidebar-item" aria-label="快速排序"><!--[--><!--]--> 快速排序 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">数据结构 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%92%8C%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0.html" class="sidebar-item" aria-label="单链表和双链表的数组实现"><!--[--><!--]--> 单链表和双链表的数组实现 <!--[--><!--]--></a><!----></li><li><a href="/code/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86.html" class="sidebar-item" aria-label="并查集"><!--[--><!--]--> 并查集 <!--[--><!--]--></a><!----></li><li><a href="/code/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.html" class="sidebar-item" aria-label="栈和队列"><!--[--><!--]--> 栈和队列 <!--[--><!--]--></a><!----></li><li><a href="/code/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91.html" class="sidebar-item" aria-label="树状数组和线段树"><!--[--><!--]--> 树状数组和线段树 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">树图 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/algorithm/%E6%A0%91%E5%9B%BE/%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95.html" class="sidebar-item" aria-label="图相关的基本算法"><!--[--><!--]--> 图相关的基本算法 <!--[--><!--]--></a><!----></li><li><a href="/code/algorithm/%E6%A0%91%E5%9B%BE/%E6%A0%91%E3%80%81%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E9%81%8D%E5%8E%86.html" class="sidebar-item" aria-label="树和图的存储及遍历"><!--[--><!--]--> 树和图的存储及遍历 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/code/algorithm/DFS%E3%80%81BFS.html" class="sidebar-item" aria-label="DFS、BFS"><!--[--><!--]--> DFS、BFS <!--[--><!--]--></a><!----></li><li><a href="/code/algorithm/KMP%E3%80%81Trie.html" class="sidebar-item" aria-label="KMP、Trie"><!--[--><!--]--> KMP、Trie <!--[--><!--]--></a><!----></li><li><a href="/code/algorithm/%E4%BA%8C%E5%88%86%E9%97%AE%E9%A2%98.html" class="sidebar-item" aria-label="二分"><!--[--><!--]--> 二分 <!--[--><!--]--></a><!----></li><li><a href="/code/algorithm/%E4%BD%8D%E8%BF%90%E7%AE%97%E3%80%81%E7%A6%BB%E6%95%A3%E5%8C%96%E3%80%81%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6.html" class="sidebar-item" aria-label="位运算、离散化、区间合并"><!--[--><!--]--> 位运算、离散化、区间合并 <!--[--><!--]--></a><!----></li><li><a href="/code/algorithm/%E5%89%8D%E7%BC%80%E5%92%8C.html" class="sidebar-item" aria-label="前缀和"><!--[--><!--]--> 前缀和 <!--[--><!--]--></a><!----></li><li><a href="/code/algorithm/%E5%8F%8C%E6%8C%87%E9%92%88.html" class="sidebar-item" aria-label="双指针"><!--[--><!--]--> 双指针 <!--[--><!--]--></a><!----></li><li><a href="/code/algorithm/%E5%A0%86%E3%80%81%E5%93%88%E5%B8%8C.html" class="sidebar-item" aria-label="堆和哈希"><!--[--><!--]--> 堆和哈希 <!--[--><!--]--></a><!----></li><li><a href="/code/algorithm/%E5%B7%AE%E5%88%86.html" class="sidebar-item" aria-label="差分"><!--[--><!--]--> 差分 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">back <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">designpattern <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/back/designpattern/DesignPattern.html" class="sidebar-item" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a><!----></li><li><a href="/code/back/designpattern/builder.html" class="sidebar-item" aria-label="builder"><!--[--><!--]--> builder <!--[--><!--]--></a><!----></li><li><a href="/code/back/designpattern/chain.html" class="sidebar-item" aria-label="builder"><!--[--><!--]--> builder <!--[--><!--]--></a><!----></li><li><a href="/code/back/designpattern/strategy.html" class="sidebar-item" aria-label="strategy"><!--[--><!--]--> strategy <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">go <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">go-zero <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/back/go/go-zero/go-zero%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5.html" class="sidebar-item" aria-label="go-zero的入门实践"><!--[--><!--]--> go-zero的入门实践 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/code/back/go/golang-plugin.html" class="sidebar-item" aria-label="golang-plugin"><!--[--><!--]--> golang-plugin <!--[--><!--]--></a><!----></li><li><a href="/code/back/go/golang%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8.html" class="sidebar-item" aria-label="golang基础入门"><!--[--><!--]--> golang基础入门 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">mq <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">rocketmq <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/back/mq/rocketmq/summary-question.html" class="sidebar-item" aria-label="summary-question"><!--[--><!--]--> summary-question <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">redis <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/back/redis/redis%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html" class="sidebar-item" aria-label="redis使用场景"><!--[--><!--]--> redis使用场景 <!--[--><!--]--></a><!----></li><li><a href="/code/back/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96.html" class="sidebar-item" aria-label="redis持久化"><!--[--><!--]--> redis持久化 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">rust <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/back/rust/rust%E5%85%A5%E9%97%A801-%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE.html" class="sidebar-item" aria-label="rust入门01-基础配置"><!--[--><!--]--> rust入门01-基础配置 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">spring <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/back/spring/%E5%8A%A8%E6%89%8B%E5%86%99starter.html" class="sidebar-item" aria-label="动手写starter"><!--[--><!--]--> 动手写starter <!--[--><!--]--></a><!----></li><li><a href="/code/back/spring/%E9%9D%9Espring%E7%AE%A1%E7%90%86%E7%9A%84%E7%B1%BB%E4%BD%BF%E7%94%A8bean.html" class="sidebar-item" aria-label="非spring管理的类使用bean"><!--[--><!--]--> 非spring管理的类使用bean <!--[--><!--]--></a><!----></li><li><a href="/code/back/spring/%E8%87%AA%E5%AE%9A%E4%B9%89spring-cloud-gateway-filter.html" class="sidebar-item" aria-label="自定义spring-cloud-gateway-filter"><!--[--><!--]--> 自定义spring-cloud-gateway-filter <!--[--><!--]--></a><!----></li><li><a href="/code/back/spring/springboot%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%9C%BA%E5%88%B6.html" class="sidebar-item" aria-label="springboot发布订阅机制"><!--[--><!--]--> springboot发布订阅机制 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">basic <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">C <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/basic/C/C%E7%BC%96%E7%A8%8B%E6%9D%82%E8%AE%B0.html" class="sidebar-item" aria-label="C编程杂记"><!--[--><!--]--> C编程杂记 <!--[--><!--]--></a><!----></li><li><a href="/code/basic/C/Makefile.html" class="sidebar-item" aria-label="Makefile"><!--[--><!--]--> Makefile <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">arch <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/basic/arch/risc-v.html" class="sidebar-item" aria-label="risc-v"><!--[--><!--]--> risc-v <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">computer-organization <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/basic/computer-organization/computer-summary.html" class="sidebar-item" aria-label="computer-summary"><!--[--><!--]--> computer-summary <!--[--><!--]--></a><!----></li><li><a href="/code/basic/computer-organization/system-bus.html" class="sidebar-item" aria-label="system-bus"><!--[--><!--]--> system-bus <!--[--><!--]--></a><!----></li><li><a href="/code/basic/computer-organization/%E6%B1%87%E7%BC%96%E4%B8%8B%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8.html" class="sidebar-item" aria-label="汇编下的函数调用"><!--[--><!--]--> 汇编下的函数调用 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">csapp <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/basic/csapp/csapp-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86.html" class="sidebar-item" aria-label="csapp-信息的表示和处理"><!--[--><!--]--> csapp-信息的表示和处理 <!--[--><!--]--></a><!----></li><li><a href="/code/basic/csapp/csapp-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA(1).html" class="sidebar-item" aria-label="csapp-程序的机器级表示(1)"><!--[--><!--]--> csapp-程序的机器级表示(1) <!--[--><!--]--></a><!----></li><li><a href="/code/basic/csapp/csapp-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA(2).html" class="sidebar-item" aria-label="csapp-程序的机器级表示(2)"><!--[--><!--]--> csapp-程序的机器级表示(2) <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">network <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/basic/network/network-ttd-application.html" class="sidebar-item" aria-label="network-ttd-application"><!--[--><!--]--> network-ttd-application <!--[--><!--]--></a><!----></li><li><a href="/code/basic/network/network-ttd-summary.html" class="sidebar-item" aria-label="network-ttd-summary"><!--[--><!--]--> network-ttd-summary <!--[--><!--]--></a><!----></li><li><a href="/code/basic/network/snmp-Java.html" class="sidebar-item" aria-label="snmp-Java"><!--[--><!--]--> snmp-Java <!--[--><!--]--></a><!----></li><li><a href="/code/basic/network/snmp%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95.html" class="sidebar-item" aria-label="snmp压力测试"><!--[--><!--]--> snmp压力测试 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">ostep <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/basic/ostep/ostep-virtualization-cpu.html" class="sidebar-item" aria-label="ostep-virtualization-cpu"><!--[--><!--]--> ostep-virtualization-cpu <!--[--><!--]--></a><!----></li><li><a href="/code/basic/ostep/ostep-virtualization-memory.html" class="sidebar-item" aria-label="ostep-virtualization-memory"><!--[--><!--]--> ostep-virtualization-memory <!--[--><!--]--></a><!----></li><li><a href="/code/basic/ostep/ostep-concurrency.html" class="sidebar-item" aria-label="ostep-concurrency"><!--[--><!--]--> ostep-concurrency <!--[--><!--]--></a><!----></li><li><a href="/code/basic/ostep/ostep-persistence.html" class="sidebar-item" aria-label="ostep-persistence"><!--[--><!--]--> ostep-persistence <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">sundry <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/basic/sundry/CPU%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7.html" class="sidebar-item" aria-label="CPU缓存一致性"><!--[--><!--]--> CPU缓存一致性 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">ysyx <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/basic/ysyx/%E5%85%B3%E4%BA%8E%E6%8F%90%E9%97%AE.html" class="sidebar-item" aria-label="关于提问"><!--[--><!--]--> 关于提问 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">distribute <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">mit-6.824 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">lab <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/distribute/mit-6.824/lab/MapReduce.html" class="sidebar-item" aria-label="MapReduce"><!--[--><!--]--> MapReduce <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/code/distribute/mit-6.824/Introduction-MapReduce.html" class="sidebar-item" aria-label="Introduction-MapReduce"><!--[--><!--]--> Introduction-MapReduce <!--[--><!--]--></a><!----></li><li><a href="/code/distribute/mit-6.824/GFS.html" class="sidebar-item" aria-label="GFS"><!--[--><!--]--> GFS <!--[--><!--]--></a><!----></li><li><a href="/code/distribute/mit-6.824/Backup-VMware.html" class="sidebar-item" aria-label="Backup-VMware"><!--[--><!--]--> Backup-VMware <!--[--><!--]--></a><!----></li><li><a href="/code/distribute/mit-6.824/Zookeeper.html" class="sidebar-item" aria-label="Zookeeper"><!--[--><!--]--> Zookeeper <!--[--><!--]--></a><!----></li><li><a href="/code/distribute/mit-6.824/%E9%93%BE%E5%BC%8F%E5%A4%8D%E5%88%B6.html" class="sidebar-item" aria-label="链式复制"><!--[--><!--]--> 链式复制 <!--[--><!--]--></a><!----></li><li><a href="/code/distribute/mit-6.824/Frangipani.html" class="sidebar-item" aria-label="Frangipani"><!--[--><!--]--> Frangipani <!--[--><!--]--></a><!----></li><li><a href="/code/distribute/mit-6.824/Spanner.html" class="sidebar-item" aria-label="Spanner"><!--[--><!--]--> Spanner <!--[--><!--]--></a><!----></li><li><a href="/code/distribute/mit-6.824/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.html" class="sidebar-item" aria-label="分布式事务"><!--[--><!--]--> 分布式事务 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">front <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">angular <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/front/angular/Angular%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%9F%BA%E7%A1%80%E8%AE%A4%E7%9F%A5.html" class="sidebar-item" aria-label="Angular环境配置和基础认知"><!--[--><!--]--> Angular环境配置和基础认知 <!--[--><!--]--></a><!----></li><li><a href="/code/front/angular/Angular%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8.html" class="sidebar-item" aria-label="Angular基础入门"><!--[--><!--]--> Angular基础入门 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">es6 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/front/es6/ES6-01%20let%E5%92%8Cconst.html" class="sidebar-item" aria-label="ES6-01 let&amp;const"><!--[--><!--]--> ES6-01 let&amp;const <!--[--><!--]--></a><!----></li><li><a href="/code/front/es6/ES6-02%20%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC.html" class="sidebar-item" aria-label="ES6-02 解构赋值"><!--[--><!--]--> ES6-02 解构赋值 <!--[--><!--]--></a><!----></li><li><a href="/code/front/es6/ES6-03%20class.html" class="sidebar-item" aria-label="ES6-03 class"><!--[--><!--]--> ES6-03 class <!--[--><!--]--></a><!----></li><li><a href="/code/front/es6/ES6-04%20ES6%E6%96%B0%E5%A2%9E%E7%94%A8%E6%B3%95.html" class="sidebar-item" aria-label="ES6-04 ES6新增用法"><!--[--><!--]--> ES6-04 ES6新增用法 <!--[--><!--]--></a><!----></li><li><a href="/code/front/es6/ES6-05%20Symbol.html" class="sidebar-item" aria-label="ES6-05 Symbol"><!--[--><!--]--> ES6-05 Symbol <!--[--><!--]--></a><!----></li><li><a href="/code/front/es6/ES6-06%20Module%E7%9A%84%E5%AF%BC%E5%85%A5%E5%92%8C%E5%AF%BC%E5%87%BA.html" class="sidebar-item" aria-label="ES6-06 Module的导入和导出"><!--[--><!--]--> ES6-06 Module的导入和导出 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">leetcode <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">dp <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/leetcode/dp/%E6%9C%80%E9%95%BF%E7%B3%BB%E5%88%97.html" class="sidebar-item" aria-label="最长系列"><!--[--><!--]--> 最长系列 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">link <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/leetcode/link/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.html" class="sidebar-item" aria-label="反转链表"><!--[--><!--]--> 反转链表 <!--[--><!--]--></a><!----></li><li><a href="/code/leetcode/link/%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8.html" class="sidebar-item" aria-label="合并链表"><!--[--><!--]--> 合并链表 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">二分 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/leetcode/%E4%BA%8C%E5%88%86/%E6%95%B0%E7%9A%84%E4%BA%8C%E6%AC%A1%E6%96%B9%E6%A0%B9.html" class="sidebar-item" aria-label="数的二次方根"><!--[--><!--]--> 数的二次方根 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">回溯 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/leetcode/%E5%9B%9E%E6%BA%AF/%E7%BB%84%E5%90%88.html" class="sidebar-item" aria-label="组合"><!--[--><!--]--> 组合 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item active collapsible">linux <span class="down arrow"></span></p><ul style="" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">ebpf <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/linux/ebpf/ebpf%E6%9D%82%E8%AE%B0.html" class="sidebar-item" aria-label="ebpf杂记"><!--[--><!--]--> ebpf杂记 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/code/linux/kernel-user-buffer.html" class="sidebar-item" aria-label="kernel-user-buffer"><!--[--><!--]--> kernel-user-buffer <!--[--><!--]--></a><!----></li><li><a href="/code/linux/page-cache.html" class="sidebar-item" aria-label="page-cache"><!--[--><!--]--> page-cache <!--[--><!--]--></a><!----></li><li><a href="/code/linux/%E9%9B%B6%E6%8B%B7%E8%B4%9D.html" class="sidebar-item" aria-label="zero-cpoy"><!--[--><!--]--> zero-cpoy <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/code/linux/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="IO多路复用"><!--[--><!--]--> IO多路复用 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/code/linux/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#c10k" class="router-link-active router-link-exact-active sidebar-item" aria-label="C10K"><!--[--><!--]--> C10K <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/code/linux/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#io模型" class="router-link-active router-link-exact-active sidebar-item" aria-label="IO模型"><!--[--><!--]--> IO模型 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/code/linux/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#阻塞io" class="router-link-active router-link-exact-active sidebar-item" aria-label="阻塞IO"><!--[--><!--]--> 阻塞IO <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/code/linux/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#同步非阻塞io" class="router-link-active router-link-exact-active sidebar-item" aria-label="同步非阻塞IO"><!--[--><!--]--> 同步非阻塞IO <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/code/linux/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#异步io" class="router-link-active router-link-exact-active sidebar-item" aria-label="异步IO"><!--[--><!--]--> 异步IO <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/code/linux/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#信号驱动io" class="router-link-active router-link-exact-active sidebar-item" aria-label="信号驱动IO"><!--[--><!--]--> 信号驱动IO <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/code/linux/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#io多路复用" class="router-link-active router-link-exact-active sidebar-item" aria-label="IO多路复用"><!--[--><!--]--> IO多路复用 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/code/linux/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#非阻塞式io实现多路复用" class="router-link-active router-link-exact-active sidebar-item" aria-label="非阻塞式IO实现多路复用"><!--[--><!--]--> 非阻塞式IO实现多路复用 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/code/linux/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#select" class="router-link-active router-link-exact-active sidebar-item" aria-label="select"><!--[--><!--]--> select <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/code/linux/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#poll" class="router-link-active router-link-exact-active sidebar-item" aria-label="poll"><!--[--><!--]--> poll <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/code/linux/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#epoll" class="router-link-active router-link-exact-active sidebar-item" aria-label="epoll"><!--[--><!--]--> epoll <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/code/linux/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#epoll为什么高效" class="router-link-active router-link-exact-active sidebar-item" aria-label="epoll为什么高效"><!--[--><!--]--> epoll为什么高效 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/code/linux/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#epoll的边缘触发与水平触发" class="router-link-active router-link-exact-active sidebar-item" aria-label="epoll的边缘触发与水平触发"><!--[--><!--]--> epoll的边缘触发与水平触发 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/code/linux/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#总结" class="router-link-active router-link-exact-active sidebar-item" aria-label="总结"><!--[--><!--]--> 总结 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/code/linux/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#reactor" class="router-link-active router-link-exact-active sidebar-item" aria-label="Reactor"><!--[--><!--]--> Reactor <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/code/linux/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#单线程模式" class="router-link-active router-link-exact-active sidebar-item" aria-label="单线程模式"><!--[--><!--]--> 单线程模式 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/code/linux/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#多线程模型" class="router-link-active router-link-exact-active sidebar-item" aria-label="多线程模型"><!--[--><!--]--> 多线程模型 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/code/linux/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#主从线程模型" class="router-link-active router-link-exact-active sidebar-item" aria-label="主从线程模型"><!--[--><!--]--> 主从线程模型 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a href="/code/linux/kernel-bypass.html" class="sidebar-item" aria-label="kernel-bypass"><!--[--><!--]--> kernel-bypass <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">mysql <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/mysql/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html" class="sidebar-item" aria-label="存储引擎"><!--[--><!--]--> 存储引擎 <!--[--><!--]--></a><!----></li><li><a href="/code/mysql/%E4%BA%8B%E5%8A%A1.html" class="sidebar-item" aria-label="事务"><!--[--><!--]--> 事务 <!--[--><!--]--></a><!----></li><li><a href="/code/mysql/%E7%B4%A2%E5%BC%95.html" class="sidebar-item" aria-label="索引"><!--[--><!--]--> 索引 <!--[--><!--]--></a><!----></li><li><a href="/code/mysql/%E9%94%81.html" class="sidebar-item" aria-label="锁"><!--[--><!--]--> 锁 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">sundry <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/sundry/snowflakeid.html" class="sidebar-item" aria-label="snowflakeid"><!--[--><!--]--> snowflakeid <!--[--><!--]--></a><!----></li><li><a href="/code/sundry/%E5%B9%82%E7%AD%89.html" class="sidebar-item" aria-label="幂等"><!--[--><!--]--> 幂等 <!--[--><!--]--></a><!----></li><li><a href="/code/sundry/%E7%A7%92%E6%9D%80%E5%9C%BA%E6%99%AF.html" class="sidebar-item" aria-label="秒杀场景"><!--[--><!--]--> 秒杀场景 <!--[--><!--]--></a><!----></li><li><a href="/code/sundry/%E9%99%90%E6%B5%81.html" class="sidebar-item" aria-label="限流"><!--[--><!--]--> 限流 <!--[--><!--]--></a><!----></li><li><a href="/code/sundry/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html" class="sidebar-item" aria-label="分布式锁"><!--[--><!--]--> 分布式锁 <!--[--><!--]--></a><!----></li><li><a href="/code/sundry/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.html" class="sidebar-item" aria-label="两阶段提交"><!--[--><!--]--> 两阶段提交 <!--[--><!--]--></a><!----></li><li><a href="/code/sundry/COW-%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6.html" class="sidebar-item" aria-label="COW-写时复制"><!--[--><!--]--> COW-写时复制 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">interview <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">pre <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/interview/pre/Java-%E5%96%9C%E9%A9%AC%E6%8B%89%E9%9B%85-%E5%AE%9E%E4%B9%A0-23-8-21.html" class="sidebar-item" aria-label="Java-喜马拉雅-实习生-23-8-21"><!--[--><!--]--> Java-喜马拉雅-实习生-23-8-21 <!--[--><!--]--></a><!----></li><li><a href="/interview/pre/Java-%E6%95%B0%E6%96%B0%E7%BD%91%E7%BB%9C-%E5%AE%9E%E4%B9%A0-23-12-07.html" class="sidebar-item" aria-label="Java-数新网络-实习-23-12-07"><!--[--><!--]--> Java-数新网络-实习-23-12-07 <!--[--><!--]--></a><!----></li><li><a href="/interview/pre/Golang-%E7%99%BE%E5%BA%A6-%E5%AE%9E%E4%B9%A0-23-12-11.html" class="sidebar-item" aria-label="Golang-百度-实习-23-12-11"><!--[--><!--]--> Golang-百度-实习-23-12-11 <!--[--><!--]--></a><!----></li><li><a href="/interview/pre/Golang-%E4%B8%87%E5%A3%B0%E9%9F%B3%E4%B9%90-%E5%AE%9E%E4%B9%A0-23-12-27.html" class="sidebar-item" aria-label="Golang-万声音乐-实习-23-12-27.md"><!--[--><!--]--> Golang-万声音乐-实习-23-12-27.md <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">wait <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/interview/wait/go.html" class="sidebar-item" aria-label="go面经"><!--[--><!--]--> go面经 <!--[--><!--]--></a><!----></li><li><a href="/interview/wait/java.html" class="sidebar-item" aria-label="java面经"><!--[--><!--]--> java面经 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/interview/JUC.html" class="sidebar-item" aria-label="JUC常见面试题"><!--[--><!--]--> JUC常见面试题 <!--[--><!--]--></a><!----></li><li><a href="/interview/Java.html" class="sidebar-item" aria-label="Java常见面试题"><!--[--><!--]--> Java常见面试题 <!--[--><!--]--></a><!----></li><li><a href="/interview/Redis.html" class="sidebar-item" aria-label="Redis面经"><!--[--><!--]--> Redis面经 <!--[--><!--]--></a><!----></li><li><a href="/interview/algorithm.html" class="sidebar-item" aria-label="算法和数据结构面经"><!--[--><!--]--> 算法和数据结构面经 <!--[--><!--]--></a><!----></li><li><a href="/interview/mysql.html" class="sidebar-item" aria-label="MySQL面试题总结"><!--[--><!--]--> MySQL面试题总结 <!--[--><!--]--></a><!----></li><li><a href="/interview/network.html" class="sidebar-item" aria-label="网络面经"><!--[--><!--]--> 网络面经 <!--[--><!--]--></a><!----></li><li><a href="/interview/spring.html" class="sidebar-item" aria-label="sprin常见面试题"><!--[--><!--]--> sprin常见面试题 <!--[--><!--]--></a><!----></li><li><a href="/interview/sundry.html" class="sidebar-item" aria-label="sundry"><!--[--><!--]--> sundry <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">project <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">12306 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">service <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/project/12306/service/%E7%94%A8%E6%88%B7%E6%9C%8D%E5%8A%A1.html" class="sidebar-item" aria-label="用户服务"><!--[--><!--]--> 用户服务 <!--[--><!--]--></a><!----></li><li><a href="/project/12306/service/%E6%94%AF%E4%BB%98%E6%9C%8D%E5%8A%A1.html" class="sidebar-item" aria-label="支付服务"><!--[--><!--]--> 支付服务 <!--[--><!--]--></a><!----></li><li><a href="/project/12306/service/%E8%AE%A2%E5%8D%95%E6%9C%8D%E5%8A%A1.html" class="sidebar-item" aria-label="订单服务"><!--[--><!--]--> 订单服务 <!--[--><!--]--></a><!----></li><li><a href="/project/12306/service/%E7%A5%A8%E5%8A%A1%E6%9C%8D%E5%8A%A1.html" class="sidebar-item" aria-label="票务服务"><!--[--><!--]--> 票务服务 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">中间件 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/project/12306/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis.html" class="sidebar-item" aria-label="Redis"><!--[--><!--]--> Redis <!--[--><!--]--></a><!----></li><li><a href="/project/12306/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMq.html" class="sidebar-item" aria-label="RocketMQ"><!--[--><!--]--> RocketMQ <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/project/12306/%E9%A1%B9%E7%9B%AE%E5%87%86%E5%A4%87.html" class="sidebar-item" aria-label="项目准备"><!--[--><!--]--> 项目准备 <!--[--><!--]--></a><!----></li><li><a href="/project/12306/%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91.html" class="sidebar-item" aria-label="组件开发"><!--[--><!--]--> 组件开发 <!--[--><!--]--></a><!----></li><li><a href="/project/12306/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E8%AE%BE%E8%AE%A1.html" class="sidebar-item" aria-label="数据库表设计"><!--[--><!--]--> 数据库表设计 <!--[--><!--]--></a><!----></li><li><a href="/project/12306/%E6%B5%8B%E8%AF%95.html" class="sidebar-item" aria-label="测试"><!--[--><!--]--> 测试 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">summer-framework <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/project/summer-framework/IOC.html" class="sidebar-item" aria-label="IOC"><!--[--><!--]--> IOC <!--[--><!--]--></a><!----></li><li><a href="/project/summer-framework/AOP.html" class="sidebar-item" aria-label="AOP"><!--[--><!--]--> AOP <!--[--><!--]--></a><!----></li><li><a href="/project/summer-framework/JdbcTemplate-Transaction.html" class="sidebar-item" aria-label="JdbcTemplate-Transaction"><!--[--><!--]--> JdbcTemplate-Transaction <!--[--><!--]--></a><!----></li><li><a href="/project/summer-framework/MVC.html" class="sidebar-item" aria-label="MVC"><!--[--><!--]--> MVC <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">template <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/template/markdown.html" class="sidebar-item" aria-label="markdown的使用"><!--[--><!--]--> markdown的使用 <!--[--><!--]--></a><!----></li><li><a href="/template/mermaid%E4%BD%BF%E7%94%A8.html" class="sidebar-item" aria-label="mermaid使用"><!--[--><!--]--> mermaid使用 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">think <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/think/how-to-learn.html" class="sidebar-item" aria-label="how-to-learn"><!--[--><!--]--> how-to-learn <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h2 id="c10k" tabindex="-1"><a class="header-anchor" href="#c10k" aria-hidden="true">#</a> C10K</h2><p><a href="https://zhuanlan.zhihu.com/p/23114695" target="_blank" rel="noopener noreferrer">上一个10年，著名的C10K并发连接问题<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>C10K曾是高性能网络编程中的一大难题，即单机并发超过一万。当时刚到达web2.0时，网页交互开始流行，然后发展到即时通信和实时互动，而且都需要通过TCP<strong>保持连接</strong>才能进行实时交互。这就会导致当一次HTTP请求/响应成功后，TCP不会立即断开连接，即使当前socket上并没有请求发送。</p><p>在最初的服务器都是基于进程/线程模型的，新到来<strong>一个TCP连接</strong>，就需要分配<strong>1个进程</strong>（或者线程）。而进程又是操作系统最昂贵的资源，一台机器无法创建很多进程。如果是C10K就要创建1万个进程，<strong>上下文切换</strong>会极其频繁，那么单机而言操作系统是无法承受的（往往出现效率低下甚至完全瘫痪）。这就会导致即使socket没有请求，线程依然需要阻塞read，直到socket被关闭。</p><p>那么就需要新的IO模型来提高性能。（C10M是通过绕过OS和硬件直接交互解决的）</p><h2 id="io模型" tabindex="-1"><a class="header-anchor" href="#io模型" aria-hidden="true">#</a> IO模型</h2><p><a href="https://blog.csdn.net/ldw201510803006/article/details/119767467?spm=1001.2014.3001.5501" target="_blank" rel="noopener noreferrer">一文搞懂，4种主要的 I/O 模型<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>当用户线程发起 I/O 操作后，网络数据读取操作会经历两个步骤：</p><ul><li>用户线程等待内核将数据从网卡拷贝到内核空间。</li><li>内核将数据从内核空间拷贝到用户空间</li></ul><p><strong>阻塞与非阻塞</strong>：指应用程序在发起 I/O 操作时，是立即返回还是等待</p><p><strong>同步与异步</strong>：指应用程序在与内核通信时，数据从内核空间到应用空间的拷贝，是由内核主动发起还是由应用程序来触发；内核主动发起则是异步，反之为同步</p><h3 id="阻塞io" tabindex="-1"><a class="header-anchor" href="#阻塞io" aria-hidden="true">#</a> 阻塞IO</h3><p>传统的IO模型是以 <code>read()</code>为代表的阻塞式IO，在使用read系统调用后，用户态线程陷入内核态，阻塞等待数据拷贝到用户区。</p><div class="language-pseudocode line-numbers-mode" data-ext="pseudocode"><pre class="language-pseudocode"><code>listenfd = socket();   // 打开一个网络通信端口
bind(listenfd);        // 绑定
listen(listenfd);      // 监听
while(1) {
  connfd = accept(listenfd);  // 阻塞建立连接
  int n = read(connfd, buf);  // 阻塞读数据
  doSomeThing(buf);  // 利用读到的数据做些什么
  close(connfd);     // 关闭连接，循环等待下一个连接
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/56cb9cd5fc6741cd7d508f15a1eba631.gif" style="zoom:67%;"><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/b7cc284fd97e6dbf9c32dac4c730ba91.png" alt="image-20231123173330361" style="zoom:50%;"><h3 id="同步非阻塞io" tabindex="-1"><a class="header-anchor" href="#同步非阻塞io" aria-hidden="true">#</a> 同步非阻塞IO</h3><p>用户线程不断的发起 read 调用，数据没到内核空间时，每次都返回失败（<strong>非阻塞</strong>），直到数据到了内核空间，这一次 read 调用后，在等待数据从内核空间拷贝到用户空间这段时间里，线程还是<strong>阻塞</strong>的，等数据到了用户空间再把线程叫醒。</p><p>这里需要使用<code>fcntl</code>将fd设置为非阻塞模式。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">fcntl</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> F_SETFL<span class="token punctuation">,</span> O_NONBLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> buffer<span class="token punctuation">)</span> <span class="token operator">!=</span> SUCCESS<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/af49b6370850ff03f59cb71d5bb0a219.gif" style="zoom:67%;"><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/24c4916de101b24950c70409eeadbb93.png" alt="image-20231123173401180" style="zoom:50%;"><h3 id="异步io" tabindex="-1"><a class="header-anchor" href="#异步io" aria-hidden="true">#</a> 异步IO</h3><p>用户线程发起 read 调用的同时注册一个回调函数，read 立即返回，等<strong>内核将数据准备好</strong>后，再调用指定的<strong>回调函数</strong>完成处理。在这个过程中，用户线程<strong>一直没有阻塞</strong>。</p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/ed78d1dddf67b47ac662f48e1c4e6357.png" alt="image-20231123173858699" style="zoom:50%;"><h3 id="信号驱动io" tabindex="-1"><a class="header-anchor" href="#信号驱动io" aria-hidden="true">#</a> 信号驱动IO</h3><p><a href="https://zhuanlan.zhihu.com/p/115220699" target="_blank" rel="noopener noreferrer">一文看懂IO多路复用<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p><a href="https://link.zhihu.com/?target=http%3A//man7.org/linux/man-pages/man7/signal.7.html" target="_blank" rel="noopener noreferrer">信号驱动IO<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>是利用信号机制，让内核告知应用程序文件描述符的相关事件。这里有一个信号驱动IO相关的<a href="https://link.zhihu.com/?target=https%3A//github.com/troydhanson/network/blob/master/tcp/server/sigio-server.c" target="_blank" rel="noopener noreferrer">例子<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>。</p><p>但信号驱动IO在网络编程的时候通常很少用到，因为在网络环境中，和socket相关的读写事件太多了，比如下面的事件都会导致SIGIO信号的产生：</p><ol><li>TCP连接建立</li><li>一方断开TCP连接请求</li><li>断开TCP连接请求完成</li><li>TCP连接半关闭</li><li>数据到达TCP socket</li><li>数据已经发送出去(如：写buffer有空余空间)</li></ol><p>上面所有的这些都会产生SIGIO信号，但我们没办法在SIGIO对应的信号处理函数中区分上述不同的事件，SIGIO只应该在IO事件单一情况下使用，比如说用来监听端口的socket，因为只有客户端发起新连接的时候才会产生SIGIO信号。</p><p>它和异步IO最大的不同是，当数据到达内核后，内核不会主动将数据传递给用户，而是需要用户阻塞拷贝。</p><h2 id="io多路复用" tabindex="-1"><a class="header-anchor" href="#io多路复用" aria-hidden="true">#</a> IO多路复用</h2><p><a href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;mid=2247494866&amp;idx=1&amp;sn=0ebeb60dbc1fd7f9473943df7ce5fd95&amp;chksm=c2c5967ff5b21f69030636334f6a5a7dc52c0f4de9b668f7bac15b2c1a2660ae533dd9878c7c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">你管这破玩意叫 IO 多路复用？<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>IO多路复用也是IO模型的一种，在这里将它挑出来重点叙述。</p><p>在传统的阻塞式IO中我们一次只能接收一个请求，于是后面就产生了多线程处理模式，处理逻辑放在新的线程中执行，主线程就可以继续接收请求。但在C10K中我们知道，每当一个连接到来时就创建一个对应的线程会极大的影响性能，很大的原因就是socket不是一直都有请求的。</p><p>那么我们就需要想一个其他的办法，能够同时监听多个socket上的请求。这里既可以包括监听套接字上的连接请求，也可以包括已连接套接字上的读写请求。</p><h3 id="非阻塞式io实现多路复用" tabindex="-1"><a class="header-anchor" href="#非阻塞式io实现多路复用" aria-hidden="true">#</a> 非阻塞式IO实现多路复用</h3><p>好像，上面所叙述的非阻塞式IO就可以实现？每当我们接收到一个accept，就将它放进一个数组中。然后只需要遍历数组，使用非阻塞IO处理已就绪的请求，如果有请求到达，再创建线程处理。</p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/b499e399a9b1a4ae26813f355bb87e4b.gif" style="zoom:67%;"><p>但是我们会发现，每次read其实都需要陷入一次内核态，需要两次上下文切换，当连接多起来时，显然很不划算。</p><blockquote><p>在 while 循环里做系统调用，就好比你做分布式项目时在 while 里做 rpc 请求一样，是不划算的。</p></blockquote><p>那我们就想，怎样才能即非阻塞又不去过多的陷入内核态呢？</p><h3 id="select" tabindex="-1"><a class="header-anchor" href="#select" aria-hidden="true">#</a> select</h3><p>当然是让操作系统帮我们实现啦。既然我们每次都需要陷入内核态才可以判断是否可读，直接让os在内核态帮我们遍历好了:happy:</p><p>select函数就是帮我们做这件事情的，我们将fd数组传入，操作系统帮我们遍历判断socket是否可读，一旦有可读的socket，就返回可读的数量。可以看出select是阻塞的。</p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/320be0c91e2a376199b1d5eef626758e.gif" style="zoom:67%;"><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/6705367fe23e0f4e87dcac35903b4a78.png" alt="image-20231123191613036" style="zoom:50%;"><p>select函数原型如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__FD_SETSIZE</span> <span class="token expression"><span class="token number">1024</span> </span></span>
<span class="token keyword">int</span> <span class="token function">select</span><span class="token punctuation">(</span>
    <span class="token keyword">int</span> nfds<span class="token punctuation">,</span>
    fd_set <span class="token operator">*</span>readfds<span class="token punctuation">,</span>
    fd_set <span class="token operator">*</span>writefds<span class="token punctuation">,</span>
    fd_set <span class="token operator">*</span>exceptfds<span class="token punctuation">,</span>
    <span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token operator">*</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// nfds:监控的文件描述符集里最大文件描述符加1</span>
<span class="token comment">// readfds：监控有读数据到达文件描述符集合，传入传出参数</span>
<span class="token comment">// writefds：监控写数据到达文件描述符集合，传入传出参数</span>
<span class="token comment">// exceptfds：监控异常发生达文件描述符集合, 传入传出参数</span>
<span class="token comment">// timeout：定时阻塞监控时间，3种情况</span>
<span class="token comment">//  1.NULL，永远等下去</span>
<span class="token comment">//  2.设置timeval，等待固定时间</span>
<span class="token comment">//  3.设置timeval里时间均为0，检查描述字后立即返回，轮询</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
   …
   __fd_mask  __fds_bits<span class="token punctuation">[</span>__FD_SETSIZE <span class="token operator">/</span> __NFDBITS<span class="token punctuation">]</span><span class="token punctuation">;</span>
   …
<span class="token punctuation">}</span> fd_set
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以看出select目前的一些缺点：</p><ol><li><p>select 调用需要传入 fd 数组，需要<strong>拷贝</strong>一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）</p></li><li><p>select 函数对单个进程能<code>监听的文件描述符数量是有限制</code>的，它能监听的文件描述符个数由 <em>__FD_SETSIZE</em> 决定，默认值是 <em>1024</em>。</p></li><li><p>select 在内核层仍然是通过<strong>遍历</strong>的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）</p></li><li><p>select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己<strong>遍历</strong>。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）</p></li></ol><h3 id="poll" tabindex="-1"><a class="header-anchor" href="#poll" aria-hidden="true">#</a> poll</h3><p>poll相较于select只有一个进步，那就是不在限制数量。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token operator">*</span>fds<span class="token punctuation">,</span> nfds_tnfds<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token punctuation">{</span>
  intfd<span class="token punctuation">;</span> <span class="token comment">/*文件描述符*/</span>
  shortevents<span class="token punctuation">;</span> <span class="token comment">/*监控的事件*/</span>
  shortrevents<span class="token punctuation">;</span> <span class="token comment">/*监控事件中满足条件返回的事件*/</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="epoll" tabindex="-1"><a class="header-anchor" href="#epoll" aria-hidden="true">#</a> epoll</h3><p>而epoll直接一下子把select的缺点全都解决了😆</p><ol><li><p>内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可。（mmap）</p></li><li><p>不限制数量</p></li><li><p>内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。</p></li><li><p>内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。</p></li></ol><p>提供的函数如下：</p><ul><li><p>创建一个epoll句柄</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 参数size表明内核要监听的描述符数量</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>向内核添加、修改或删除要监控的文件描述符。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>
  <span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// epfd 表示 epoll 句柄</span>
<span class="token comment">// op 表示 fd 操作类型，有如下3种</span>
<span class="token comment">//   EPOLL_CTL_ADD 注册新的 fd 到 epfd 中</span>
<span class="token comment">//   EPOLL_CTL_MOD 修改已注册的 fd 的监听事件</span>
<span class="token comment">//   EPOLL_CTL_DEL 从 epfd 中删除一个 fd</span>
<span class="token comment">//   fd 是要监听的描述符</span>
<span class="token comment">// event 表示要监听的事件</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>类似于select的阻塞调用</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span>
  <span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>events<span class="token punctuation">,</span> <span class="token keyword">int</span> max events<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// epfd 是 epoll 句柄</span>
<span class="token comment">// events 表示从内核得到的就绪事件集合</span>
<span class="token comment">// maxevents 告诉内核 events 的大小</span>
<span class="token comment">// timeout 表示等待的超时事件</span>

<span class="token keyword">typedef</span> <span class="token keyword">union</span> epoll_data
<span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">int</span> fd<span class="token punctuation">;</span>  <span class="token comment">//记录文件描述符</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> <span class="token class-name">epoll_data_t</span><span class="token punctuation">;</span>


<span class="token keyword">struct</span> <span class="token class-name">epoll_event</span>
<span class="token punctuation">{</span>
  <span class="token class-name">uint32_t</span> events<span class="token punctuation">;</span>  <span class="token comment">//epoll监听的事件类型</span>
  <span class="token class-name">epoll_data_t</span> data<span class="token punctuation">;</span> <span class="token comment">//应用程序数据</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 常见的事件</span>
<span class="token comment">// EPOLLIN：读事件，表示文件描述符对应套接字有数据可读。</span>
<span class="token comment">// EPOLLOUT：写事件，表示文件描述符对应套接字有数据要写。</span>
<span class="token comment">// EPOLLERR：错误事件，表示文件描述符对于套接字出错。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/70f8e9bc1a028d252c01c32329e49341.gif" style="zoom:67%;"></li></ul><p>epoll如何处理写事件？<a href="https://blog.csdn.net/The_Old_man_and_sea/article/details/102633590" target="_blank" rel="noopener noreferrer">I/O 多路复用如何高效处理写事件<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h3 id="epoll为什么高效" tabindex="-1"><a class="header-anchor" href="#epoll为什么高效" aria-hidden="true">#</a> epoll为什么高效</h3><ol><li><p>epoll 采用红黑树管理文件描述符 从上图可以看出，epoll使用红黑树管理文件描述符，红黑树插入和删除的都是时间复杂度 O(logN)，不会随着文件描述符数量增加而改变。 select、poll采用数组或者链表的形式管理文件描述符，那么在遍历文件描述符时，时间复杂度会随着文件描述的增加而增加。</p></li><li><p>epoll 将文件描述符添加和检测分离，减少了文件描述符拷贝的消耗 select&amp;poll 调用时会将全部监听的 fd 从用户态空间拷贝至内核态空间并线性扫描一遍找出就绪的 fd 再返回到用户态。下次需要监听时，又需要把之前已经传递过的文件描述符再读传递进去，增加了拷贝文件的无效消耗，当文件描述很多时，性能瓶颈更加明显。 而epoll只需要使用epoll_ctl添加一次，后续的检查使用epoll_wait，减少了文件拷贝的消耗。</p></li></ol><h3 id="epoll的边缘触发与水平触发" tabindex="-1"><a class="header-anchor" href="#epoll的边缘触发与水平触发" aria-hidden="true">#</a> epoll的边缘触发与水平触发</h3><p><a href="https://zhuanlan.zhihu.com/p/668197926" target="_blank" rel="noopener noreferrer">IO多路复用就这么简单<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h4 id="水平触发-lt" tabindex="-1"><a class="header-anchor" href="#水平触发-lt" aria-hidden="true">#</a> 水平触发(LT)</h4><p>关注点是数据，只要<strong>读缓冲区不为空</strong>，<strong>写缓冲区不满</strong>，那么epoll_wait就会<strong>一直返回就绪</strong>，水平触发是epoll的<strong>默认</strong>工作方式。</p><h4 id="边缘触发-et" tabindex="-1"><a class="header-anchor" href="#边缘触发-et" aria-hidden="true">#</a> 边缘触发(ET)</h4><p>关注点是<strong>变化</strong>，只要缓冲区的数据有变化，epoll_wait就会返回就绪。 这里的数据变化并不单纯指，缓冲区从有数据变为没有数据，或者从没有数据变为有数据，还包括了数据变多或者变少。换句话说，<strong>当buffer长度有变化时，就会触发</strong>。 假设epoll被设置为了边缘触发，当客户端写入了10个字符，由于缓冲区从0变为了10，于是服务端epoll_wait触发一次就绪，服务端读取了2个字节后不再读取。这个时候再去调用epoll_wait会发现不会就绪，只有当客户端再次写入数据后，才会触发就绪。 这就导致如果使用ET模式，那就必须保证要「一次性把数据读取/写入完」，否则会导致数据长期无法读取/写入。 LT模式则没有这个问题。</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><p>单线程串行处理socket事件--&gt;accept后多个线程阻塞监听自己的事件--&gt;一个线程在用户态使用非阻塞IO循环监听所有事件--&gt;操作系统遍历监听事件--&gt;操作系统利用fd的callback异步通知。</p><h2 id="reactor" tabindex="-1"><a class="header-anchor" href="#reactor" aria-hidden="true">#</a> Reactor</h2><p><a href="https://zhuanlan.zhihu.com/p/95662364" target="_blank" rel="noopener noreferrer">高性能IO模型分析-Reactor模式和Proactor模式（二）<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p><a href="https://juejin.cn/post/7092436770519777311" target="_blank" rel="noopener noreferrer">高性能网络编程之 Reactor 网络模型（彻底搞懂）<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>有了IO多路复用技术，性能确实提升了不少，但是我们会发现，好像不太容易编程，对于可连接，可读，可写事件，我们完全就是在面向过程编程，这时，Reactor模型就应运而生。</p><p>Reactor 模型其核心是<strong>事件驱动</strong>，<strong>有一个或多个并发输入源，有一个Service Handler，有多个Request Handlers</strong>。Service Handler会对输入的请求（Event）进行多路复用，并同步地将它们分发给相应的Request Handler。可以理解为 Reactor 模型中的反应器角色类似于事件转发器（承接<strong>连接建立</strong>、<strong>IO处理</strong>以及<strong>事件分发</strong>），所以Reactor模式也可称为<strong>Dispatcher</strong>模式。</p><p>Reactor通常以三种形式呈现：</p><ul><li>单线程模型</li><li>多线程模型：工作者线程池</li><li>主从多线程模型：工作者线程池，拆分Reactor</li></ul><h3 id="单线程模式" tabindex="-1"><a class="header-anchor" href="#单线程模式" aria-hidden="true">#</a> 单线程模式</h3><p>单线程模式就是由一个线程完成所有的事情：连接建立，读写事件，事件分发，业务处理。</p><p>缺点也很明显：</p><ul><li><p>一个线程支持处理的连接数非常有限，CPU 很容易打满，性能方面有明显瓶颈；</p></li><li><p>当多个事件被同时触发时，只要有一个事件没有处理完，其他后面的事件就无法执行，这就会造成消息积压及请求超时；</p></li><li><p>线程在处理 I/O 事件时，Select 无法同时处理连接建立、事件分发等操作；</p></li><li><p>如果 I/O 线程一直处于满负荷状态，很可能造成服务端节点不可用。</p></li></ul><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/fc2fc5ffee0b9e2cde3a91dc3326ae1c.png" alt="image-20231123203522878" style="zoom:50%;"><h3 id="多线程模型" tabindex="-1"><a class="header-anchor" href="#多线程模型" aria-hidden="true">#</a> 多线程模型</h3><p>在这里，我们将业务处理外包出去，使用我们常见的线程池技术来处理耗时的业务操作。</p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/8c4a0af1bac505f8b39f761f8c5eee3b.png" alt="image-20231123205101226" style="zoom:50%;"><p>但是读写操作任然是由Reactor单线程执行，阻塞问题依然存在。</p><h3 id="主从线程模型" tabindex="-1"><a class="header-anchor" href="#主从线程模型" aria-hidden="true">#</a> 主从线程模型</h3><p>主从 Reactor 模式中，分为了主 Reactor 和 从 Reactor，分别处理 <code>新建立的连接</code>、<code>IO读写事件/事件分发</code>。</p><ul><li>一来，主 Reactor 可以解决同一时间大量新连接，将其注册到从 Reactor 上进行IO事件监听处理</li><li>二来，IO事件监听相对新连接处理更加耗时，此处我们可以考虑使用线程池来处理。这样能充分利用多核 CPU 的特性，能使更多就绪的IO事件及时处理。</li></ul><p>简言之，主从多线程模型由多个 Reactor 线程组成，每个 Reactor 线程都有独立的 Selector 对象。MainReactor 仅负责处理客户端连接的 Accept 事件，连接建立成功后将新创建的连接对象注册至 SubReactor。再由 SubReactor 分配线程池中的 I/O 线程与其连接绑定，它将负责连接生命周期内所有的 I/O 事件。</p><p>在海量客户端并发请求的场景下，主从多线程模式甚至可以适当增加 SubReactor 线程的数量，从而利用多核能力提升系统的吞吐量。</p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/2d1124b96118580bbcb8708c04592feb.png" alt="image-20231123205228569" style="zoom:50%;"></div><!--[--><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">上次更新: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 2803436425@qq.com">YangZhang</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/code/linux/%E9%9B%B6%E6%8B%B7%E8%B4%9D.html" class="" aria-label="zero-cpoy"><!--[--><!--]--> zero-cpoy <!--[--><!--]--></a></span><span class="next"><a href="/code/linux/kernel-bypass.html" class="" aria-label="kernel-bypass"><!--[--><!--]--> kernel-bypass <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app-20538318.js" defer></script>
  </body>
</html>
