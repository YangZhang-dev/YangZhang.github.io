import{_ as a,r as i,o as s,c as l,a as e,b as o,d as n,e as t}from"./app-20538318.js";const c={},p=e("p",null,"由于目前的场景需要在不同的机器上进行原子操作，同时需要考虑分区和故障的情况，所以就出现了分布式事务这一概念。",-1),h=e("h2",{id:"本地事务",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#本地事务","aria-hidden":"true"},"#"),o(" 本地事务")],-1),d={href:"https://zhuanlan.zhihu.com/p/57579023",target:"_blank",rel:"noopener noreferrer"},g=t('<h3 id="事务原语" tabindex="-1"><a class="header-anchor" href="#事务原语" aria-hidden="true">#</a> 事务原语</h3><ul><li>begin：声明一个事务的开始</li><li>commit：提交事务，commit成功被执行后，begin～commit之间的逻辑被原子地执行</li><li>abort：取消事务，begin～abort之间的逻辑将被撤销，即产生的影响会消除(比如put修改的值被改回去之类的)。<strong>除了人为在逻辑里使用abort，事务本身遇到死锁等情况时也会自动调用abort</strong>。</li></ul><blockquote><p>探测死锁：</p><ul><li>基于超时。</li><li>以事务作为节点，当事务A等待事务B时，A指向B，形成一张有向图。当图中出现环时，则说明出现死锁。</li></ul></blockquote><h3 id="隔离性" tabindex="-1"><a class="header-anchor" href="#隔离性" aria-hidden="true">#</a> 隔离性</h3><p>基本概念不再陈述，重点是隔离级别中的可串行化，被称为数据库的黄金标准。乍一听和可线性化有点类似，但其实这是两个领域中截然不同的东西。</p><p>可串行化是指，并行的执行一些事物得到的结果，与按照某种串行的顺序来执行这些事务，可以得到相同的结果。实际的执行过程或许会有大量的并行处理，但是这里要求得到的结果与按照某种顺序一次一个事务的串行执行结果是一样的。所以，<strong>如果你要检查一个并发事务执行是否是可串行化的，你查看结果，并看看是否可以找到对于同一些事务，存在一次只执行一个事务的顺序，按照这个顺序执行可以生成相同的结果</strong>。</p><p>所以可串行化的执行顺序和实际的执行顺序有可能是不相同的。而可线性化的顺序是和真实时间匹配的。</p><h3 id="并发控制" tabindex="-1"><a class="header-anchor" href="#并发控制" aria-hidden="true">#</a> 并发控制</h3><p>为了达成可串行化的要求，通常由悲观和乐观两种解决方案。</p><p>悲观通过<strong>锁</strong>来保证串行，而乐观是<strong>无锁</strong>并发，当要提交时（提交点）检查当前结果是否满足串行化的要求，如果不满足则回滚。</p><h2 id="_2pl" tabindex="-1"><a class="header-anchor" href="#_2pl" aria-hidden="true">#</a> 2PL</h2>',11),u={href:"https://zhuanlan.zhihu.com/p/59535337",target:"_blank",rel:"noopener noreferrer"},_={href:"https://zhuanlan.zhihu.com/p/133823461",target:"_blank",rel:"noopener noreferrer"},m=t('<p>简单锁(simple locking)或严格锁(strict locking)，在事务开始前，需要获取整个事务所需的所有锁，持有这些锁直到提交点进行commit或者abort，然后释放所有锁。（<strong>全量获取锁</strong>）</p><p>2PL的锁更细粒度一点，不需要在事务开始前直接获取所有锁，相反的，在事务运行时<strong>动态增量的获取锁</strong>，支持某些严格锁**(<strong>简单锁</strong>)**不允许的并发模式。</p><p>在两阶段锁(2PL)中，每个记录都有锁(lock per record)，其有两条需要遵循的规则：</p><ol><li>在开始事务之前，需要lock。(T acquire lock before using)</li><li>如果一个transaction释放了它所持有的<strong>任意一个锁</strong>，那它就<strong>再也不能获取任何锁</strong>。</li></ol><p>数据库常用的SS2PL，更加严格的2PL，它要求只能在提交和回滚时释放锁，事务拥有锁之后，只能在commit或abort时释放锁。(T holds until commit or abort)，能够有效的避免<strong>级联回滚</strong>的情况。</p><h2 id="_2pc" tabindex="-1"><a class="header-anchor" href="#_2pc" aria-hidden="true">#</a> 2PC</h2>',6),b={href:"https://zhuanlan.zhihu.com/p/419829407",target:"_blank",rel:"noopener noreferrer"},f={href:"https://zhuanlan.zhihu.com/p/263555694",target:"_blank",rel:"noopener noreferrer"},M=t('<p>2PC和2PL名字很像，但是2PC是分布式场景下的事务解决方案，全称是<strong>两阶段提交协议</strong>（2 phase commit），包括<strong>准备阶段</strong>和<strong>提交阶段</strong>。在<strong>分布式事务处理模型</strong>（Distributed Transaction Processing Reference Model，DTP）的定义下，有如下的几个角色：</p><ul><li>AP(Application Program)：即应用程序，可以理解为使用DTP分布式事务的程序。</li><li>RM(Resource Manager)：即资源管理器，可以理解为事务的参与者，一般情况下是指一个数据库实例，通过资源管理器对该数据库进行控制，资源管理器控制着<strong>分支事务</strong>。</li><li>TM(Transaction Manager)：事务管理器，负责协调和管理事务，事务管理器控制着全局事务，管理事务生命周期，并协调各个RM。全局事务是指分布式事务处理环境中，需要操作多个数据库共同完成一个工作，这个工作即是一个<strong>全局事务</strong>。</li><li>DTP模型定义TM和RM之间通讯的接口规范叫<strong>XA</strong>，简单理解为数据库提供的2PC接口协议，基于数据库的XA协议来实现2PC又称为XA方案。</li></ul><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/314c21a152c257e07d2588f33382cba2.png" alt="image-20231116120325605" style="zoom:33%;"><p>在2PC中RM通常是<strong>数据库实例</strong>，如果有一个RM在prepare阶段返回no，那么TM就会控制所有RM进行回滚。</p><h3 id="崩溃分析" tabindex="-1"><a class="header-anchor" href="#崩溃分析" aria-hidden="true">#</a> 崩溃分析</h3><ul><li><p>RM在ok后崩溃</p><p>由于数据库的WAL技术存在，在操作前会先写redolog和undolog，当机器重启后会回到之前的状态，接收到commit请求，提交本地事务。</p></li><li><p>TM在ok后，commit前崩溃</p><p>这时RM就需要一直等待，不能够擅自提交或回滚事务。</p></li><li><p>RM在prepare后崩溃</p><p>TM会以超时为由回滚所有事务，如果后面RM连接上了，也会因为tid已经过时而放弃提交回滚。</p></li></ul><p>通常会使用共识算法增加TM的可用性，因为TM崩溃后，RM本地的锁也不会释放。</p><blockquote><p>分布式事务：2PC、TCC、sega、TCC、MQ事务消息、本地消息表、AT</p></blockquote>',8);function k(T,P){const r=i("ExternalLinkIcon");return s(),l("div",null,[p,h,e("p",null,[e("a",d,[o("Transaction management：可串行性（serializability）"),n(r)])]),g,e("p",null,[e("a",u,[o("Transaction management：两阶段锁（two-phase locking）"),n(r)])]),e("p",null,[e("a",_,[o("一篇讲透如何理解数据库并发控制"),n(r)])]),m,e("p",null,[e("a",b,[o("分布式事务-2PC与TCC "),n(r)])]),e("p",null,[e("a",f,[o("分布式事务有这一篇就够了！"),n(r)])]),M])}const z=a(c,[["render",k],["__file","分布式事务.html.vue"]]);export{z as default};
