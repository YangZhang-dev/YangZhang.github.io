import{_ as l,r as t,o as i,c,a,b as s,d as o,e as n}from"./app-20538318.js";const p={},r=n('<p>本章介绍有关于MySQL索引的相关知识。</p><p><strong>索引</strong>(index)是帮助MyQL高效获取数据的数据结构(有序。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/ec703018ac5b0e5b00871b92d0d89ec7.png" alt="image-20230908182429477" loading="lazy"></p><h2 id="索引结构" tabindex="-1"><a class="header-anchor" href="#索引结构" aria-hidden="true">#</a> 索引结构</h2><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/7ab5427f00ad849e7b87e5e7b94b60fd.png" alt="image-20230906185117841" style="zoom:67%;"><h3 id="b-tree" tabindex="-1"><a class="header-anchor" href="#b-tree" aria-hidden="true">#</a> B+Tree</h3>',6),d=a("strong",null,"二叉搜索树",-1),m={href:"https://zhuanlan.zhihu.com/p/29867652",target:"_blank",rel:"noopener noreferrer"},h=a("ul",null,[a("li",null,[s("当顺序插入时，二叉搜索树会退化为一个链表，搜索时间复杂度退化为"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"O"),a("mo",{stretchy:"false"},"("),a("mi",null,"n"),a("mo",{stretchy:"false"},")")]),a("annotation",{encoding:"application/x-tex"},"O(n)")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),a("span",{class:"mopen"},"("),a("span",{class:"mord mathnormal"},"n"),a("span",{class:"mclose"},")")])])])]),a("li",null,"对于大量数据，树的层级加深，检索速度慢")],-1),g=n('<p>为了解决这些缺点，这里引入了B-树（多路平衡查找树）。</p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/5c18eedc9f9aea84ae09835d3b01bec2.png" alt="image-20230908191819660" style="zoom:67%;"><p>B-树是专门为外部存储器设计的，具有<strong>磁盘友好性</strong>，它对于读取和写入大块数据有良好的性能，所以一般被用在文件系统及数据库中。</p><p>而B+树是B-树的变体，不同之处在于</p><ul><li>所有关键字存储在叶子节点出现,内部节点(非叶子节点并不存储真正的 data)，数据都集中在一个页中，<strong>减少了随机IO</strong>。同时非叶子节点扇出更多，树的高度降低，<strong>随机IO减少</strong>。</li><li>为所有叶子结点增加了一个链指针</li></ul><p>同时为了增加<strong>区间访问性</strong>，一般会对B+树进行优化：将叶子节点的单项指针变为双向指针，也就是将单链表转化为了双向链表。</p><p>每一个节点都是MySQL的最小存储单元：<strong>页</strong>（page）。</p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/79257009185f2c4fa9d920bf16ebd77f.png" alt="image-20230908192704089" style="zoom:67%;"><p>B+树相较于B树有以下特点：</p>',9),u=a("ul",null,[a("li",null,[s("查找的时间复杂度稳定在"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"O"),a("mo",{stretchy:"false"},"("),a("mi",null,"l"),a("mi",null,"o"),a("mi",null,"n"),a("mi",null,"g"),a("mi",null,"N"),a("mo",{stretchy:"false"},")")]),a("annotation",{encoding:"application/x-tex"},"O(longN)")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),a("span",{class:"mopen"},"("),a("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),a("span",{class:"mord mathnormal"},"o"),a("span",{class:"mord mathnormal"},"n"),a("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),a("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),a("span",{class:"mclose"},")")])])]),s("：对于B树来说，由于内部节点存放了数据，所以最好的时间复杂度为"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"O"),a("mo",{stretchy:"false"},"("),a("mn",null,"1"),a("mo",{stretchy:"false"},")")]),a("annotation",{encoding:"application/x-tex"},"O(1)")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),a("span",{class:"mopen"},"("),a("span",{class:"mord"},"1"),a("span",{class:"mclose"},")")])])]),s("。")]),a("li",null,[s("区间访问方便：B+树叶节点两两相连可大大增加区间访问性，可使用在范围查询等，而B-树每个节点 key 和 data 在一起，则无法区间查找。B+树可以很好的利用"),a("strong",null,"空间局部性"),s("，提前将相邻的数据加载如MySQL的BufferPool中。")]),a("li",null,"更适合外部存储：由于内部节点不存储数据，对于叶子节点就可以存储更多的数据，一次IO操作取出的页中就会存在更多的数据。")],-1),b=n(`<h3 id="hash" tabindex="-1"><a class="header-anchor" href="#hash" aria-hidden="true">#</a> hash</h3><p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/81da2fa3d7770a03d6240b9970090825.png" alt="image-20230908193537347" loading="lazy"></p><p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/ceb8c72045d1e41b833901b582d1a189.png" alt="image-20230908193739718" loading="lazy"></p><h2 id="索引分类" tabindex="-1"><a class="header-anchor" href="#索引分类" aria-hidden="true">#</a> 索引分类</h2><p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/7a215f68d32316e604e65a81982ccc23.png" alt="image-20230908194226848" loading="lazy"></p><p>按照存储类型分：</p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/ed9487ff19535f87e8077b4fe571415d.png" alt="image-20230908194329898" style="zoom:67%;"><p>按照索引个数分：</p><ul><li>单列索引</li><li>联合索引</li></ul><h2 id="索引语法" tabindex="-1"><a class="header-anchor" href="#索引语法" aria-hidden="true">#</a> 索引语法</h2><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 创建索引</span>
<span class="token keyword">create</span> <span class="token keyword">index</span> idx_table_c1_c2 <span class="token keyword">on</span> <span class="token keyword">table</span><span class="token punctuation">(</span>c1<span class="token punctuation">,</span>c2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">-- 查看索引</span>
<span class="token keyword">show</span> <span class="token keyword">index</span> <span class="token keyword">from</span> <span class="token keyword">table</span><span class="token punctuation">;</span>
<span class="token comment">-- 删除</span>
<span class="token keyword">drop</span> <span class="token keyword">index</span> idx_name <span class="token keyword">on</span> <span class="token keyword">table</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="性能分析" tabindex="-1"><a class="header-anchor" href="#性能分析" aria-hidden="true">#</a> 性能分析</h2><p>一般只对select进行性能优化，以下命令查询SQL执行频率</p><p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/55ac09a8300b52939f9e23d9998c6c45.png" alt="image-20230908195905260" loading="lazy"></p><p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/88d6263d993f8003956b4234a2efb891.png" alt="image-20230908200020905" loading="lazy"></p><p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/3008c9ca247a27c294d933434a953051.png" alt="image-20230908200135792" loading="lazy"></p><p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/3db42f8c81f9cf739f056481f8a97b26.png" alt="image-20230908200254835" loading="lazy"></p><p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/ebdebdfa05d3c5409acf8bc96890fa76.png" alt="image-20230908200322600" loading="lazy"></p><h2 id="使用原则" tabindex="-1"><a class="header-anchor" href="#使用原则" aria-hidden="true">#</a> 使用原则</h2><h3 id="最左前缀法则" tabindex="-1"><a class="header-anchor" href="#最左前缀法则" aria-hidden="true">#</a> 最左前缀法则</h3><p>对于联合索引，查询要从索引的最左侧开始，不能跳过，如果跳过某一列，那么后面字段索引将失效。</p><p>结合联合索引的结构很好理解，MySQL对于联合索引是首先按照前面的的索引进行排序，在相等时，按照后面的索引进行排序。相当后面的索引是基于前面索引的<strong>局部有序</strong>，而第一个索引是<strong>全局有序</strong>的。所以如果要跳过其中一个，后面的排序很明显无法进行了。</p><h3 id="索引失效" tabindex="-1"><a class="header-anchor" href="#索引失效" aria-hidden="true">#</a> 索引失效</h3><ul><li>联合索引中，出现了范围查询（&lt;，&gt;），范围查询右侧的列索引失效</li><li>索引类上进行运算操作</li><li>发生隐式转换（字符串和数字之间）</li><li>头部模糊查询</li><li>查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到;</li><li>没有遵循最左前缀法则</li><li>数据分布影响：如果MySQL评估使用索引慢于全表查询，则不会使用索引</li></ul><h3 id="sql提示" tabindex="-1"><a class="header-anchor" href="#sql提示" aria-hidden="true">#</a> SQL提示</h3><p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/97d619f485af9e6c55ada58f5df074bd.png" alt="image-20230908202146496" loading="lazy"></p><h3 id="回表查询" tabindex="-1"><a class="header-anchor" href="#回表查询" aria-hidden="true">#</a> 回表查询</h3><p>基于二级索引的查询并且select包含了除了索引和id以外的字段，就会出现先查二级索引，再查聚集索引的情况，因为二级索引的数据只是主键的值。</p><h3 id="索引覆盖" tabindex="-1"><a class="header-anchor" href="#索引覆盖" aria-hidden="true">#</a> 索引覆盖</h3><p>只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。explain的输出结果Extra字段为Using index时，能够触发索引覆盖。</p><p>通常使用联合索引来实现索引覆盖：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">table</span> <span class="token keyword">user</span> <span class="token punctuation">(</span>
	id <span class="token keyword">int</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">,</span>
	name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	sex <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token keyword">index</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>sex<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token keyword">engine</span><span class="token operator">=</span><span class="token keyword">innodb</span><span class="token punctuation">;</span>

<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">&quot;xx&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样二级索引的索引键值就包含了所有需要的数据，不需要再去回表查询。</p><h3 id="前缀索引" tabindex="-1"><a class="header-anchor" href="#前缀索引" aria-hidden="true">#</a> 前缀索引</h3><p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/c8deb493bb0eb749ba42e97ba32d0bee.png" alt="image-20230908202304234" loading="lazy"></p>`,35);function k(y,f){const e=t("ExternalLinkIcon");return i(),c("div",null,[r,a("p",null,[s("谈起搜索树，首先会从"),d,s("看起："),a("a",m,[s("通俗易懂讲解 二叉搜索树"),o(e)]),s("，但是二叉搜索树会有两个缺点：")]),h,g,u,b])}const z=l(p,[["render",k],["__file","索引.html.vue"]]);export{z as default};
