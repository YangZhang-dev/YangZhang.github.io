import{_ as d,r,o as s,c as l,a,b as e,d as i,w as c,e as o}from"./app-20538318.js";const h={},p=o('<p>zookeeper是一个高性能的，为分布式系统提供协调服务的程序。</p><p>可用作配置中心，注册中心，分布式锁的实现方式。</p><h2 id="replicated-state-machine" tabindex="-1"><a class="header-anchor" href="#replicated-state-machine" aria-hidden="true">#</a> Replicated state machine</h2><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/6a50a9cdebc41e25c37df29c58686b86.png" alt="image-20231105101639645" style="zoom:33%;"><h2 id="高性能" tabindex="-1"><a class="header-anchor" href="#高性能" aria-hidden="true">#</a> 高性能</h2><p>Zookeeper通过多台机器读以及操作异步化来保证高吞吐。</p><p>当请求中读操作的比例较多时，zookeeper实例越多吞吐量越高，因为读操作可以在不同的机器上进行，且不需要和master通信。</p><p>当请求中的写操作比例较多时，zookeeper实例越少吞吐量越高，写操作改变了状态，需要对状态进行同步。</p><h2 id="zookeeper的正确性" tabindex="-1"><a class="header-anchor" href="#zookeeper的正确性" aria-hidden="true">#</a> Zookeeper的正确性</h2><h3 id="一致性问题" tabindex="-1"><a class="header-anchor" href="#一致性问题" aria-hidden="true">#</a> 一致性问题</h3><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/fe7dba42438ba71dd88ff42363588012.png" alt="image-20231105103657870" style="zoom:33%;"><p>对于当前的的定义，如果有以上两个请求到达时，x的值有可能时多少？</p><p>对于第一次的读请求，由于leader获取到了大多数的保证，所以可以直接返回。但是对于下次访问时，有可能当前读操作访问数据的状态还未传播到当前访问机器，就会导致数据的不一致性。</p><blockquote><p>由于存在网络分区的原因，每一次访问的实例不一定是同一个，并且zookeeper还存在负载均衡的策略。</p></blockquote><p>那么假设第一次获取到了10，第二次呢？第二次也有可能访问到一个还未同步的机器，任然有可能读到脏数据。</p><p>由此可见zookeeper并不是线性一致性（强一致性）。</p>',16),u=o("<p><strong>线性一致性(Linearizability)</strong>，线性一致性需要保证满足一下三个条件：</p><ol><li><p><strong>整体操作顺序一致(total order of operations)</strong></p><p>即使操作实际上并发进行，你仍然可以按照整体顺序对它们进行排序。（即后续可以根据读写操作的返回值，对所有读写操作整理出一个符合逻辑的整体执行顺序）</p></li><li><p><strong>实时匹配(match real-time)</strong></p><p>顺序和真实时间匹配，如果第一个操作在第二个操作开始前就完成，那么在整体顺序中，第一个操作必须排在第二个操作之前(换言之如果这么排序后，整体的执行结果不符合逻辑，那么就不符合&quot;实时匹配&quot;)。</p></li><li><p><strong>读操作总是返回最后一次写操作的结果(read return results of last write)</strong></p></li></ol>",2),v={href:"https://zhuanlan.zhihu.com/p/505877282",target:"_blank",rel:"noopener noreferrer"},b={href:"https://zhuanlan.zhihu.com/p/42239873",target:"_blank",rel:"noopener noreferrer"},m=o(`<h3 id="zookeeper一致性保证" tabindex="-1"><a class="header-anchor" href="#zookeeper一致性保证" aria-hidden="true">#</a> zookeeper一致性保证</h3><p>zookeeper实际上对第二种情况做了保证，以下是zookeeper的<strong>一致性保证</strong>：</p><ul><li><p>对于写操作，提供线性一致性的保证。</p></li><li><p>对于所有操作，保证客户端发来的FIFO顺序。</p></li></ul><p>对于读操作，就有了以下的特点：</p><ul><li>至少可以读到自己的修改。</li><li>有可能读不到其他客户端的修改。</li><li>对于同一个数据的读取，保证第二次读取一定是与第一次读取相同或更新。</li></ul><h3 id="zookeeper一致性原理" tabindex="-1"><a class="header-anchor" href="#zookeeper一致性原理" aria-hidden="true">#</a> zookeeper一致性原理</h3><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/c2ad7fe947f4892475b933898e7ea6e2.png" alt="image-20231105112945525" style="zoom:33%;"><p>zookeeper客户端使用session来维护状态，在发送写请求时，写入成功后会返回日志的zxid，由客户端来记录保存，在随后的请求中都带上zxid。</p><p>在第二次读请求时，发现当前访问实例没有对应zxid记录，所以会阻塞等待log同步。</p><p>在最后一次读请求之前，有其他的客户端更新了日志，当时这一次请求的实例还没有同步，所以又带着上一次的zxid访问读取，这次会直接返回上一次的结果。</p><p>可以看出读请求是会存在读脏数据的，但是也是符合zookeeper的正确性定义的。</p><h2 id="zookeeper规则" tabindex="-1"><a class="header-anchor" href="#zookeeper规则" aria-hidden="true">#</a> zookeeper规则</h2><h3 id="fifo" tabindex="-1"><a class="header-anchor" href="#fifo" aria-hidden="true">#</a> FIFO</h3><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/2e7531ec46164e1de4665736bf66b376.png" alt="image-20231105115057616" style="zoom:33%;"><p>FIFO规则保证了对于上方的命令会以FIFO的顺序进行执行，使得读取的f1和f2项是最新的。但是如果exists是位于del的前面，那么读取的f1和f2就不一定是最新的了，这时就要引入watch机制。</p><h3 id="watch" tabindex="-1"><a class="header-anchor" href="#watch" aria-hidden="true">#</a> watch</h3><p>ZooKeeper 实现的方式是通过客服端和服务端分别创建有观察者的信息列表。客户端调用 getData、exist 等接口时，首先将对应的 Watch 事件放到本地的 ZKWatchManager 中进行管理。服务端在接收到客户端的请求后根据请求类型判断是否含有 Watch 事件，并将对应事件放到 WatchManager 中进行管理。</p><p>在事件触发的时候服务端通过节点的路径信息查询相应的 Watch 事件通知给客户端，客户端在接收到通知后，首先查询本地的 ZKWatchManager 获得对应的 Watch 信息处理回调操作。这种设计不但实现了一个分布式环境下的观察者模式，而且通过将客户端和服务端各自处理 Watch 事件所需要的额外信息分别保存在两端，减少彼此通信的内容。大大提升了服务的处理性能。</p><p><strong>需要注意的是客户端的 Watcher 机制是一次性的，触发后就会被删除，zookeeper保证被监听的写事件发生后，会在下一次写操作发生前完成事件通知</strong>。</p><h3 id="znode" tabindex="-1"><a class="header-anchor" href="#znode" aria-hidden="true">#</a> Znode</h3><p>ZNode有三种类型：</p><ul><li>regular：常规节点，它的容错复制了所有的东西</li><li>ephemeral：临时节点，节点会自动消失。比如session消失或Znode有段时间没有传递heartbeat，则Zookeeper认为这个Znode到期，随后自动删除这个Znode节点</li><li>sequential：顺序节点，它的名字和它的version有关，是在特定的znode下创建的，这些子节点在名字中带有序列号，且节点们按照序列号排序（序号递增）。</li></ul><h3 id="api" tabindex="-1"><a class="header-anchor" href="#api" aria-hidden="true">#</a> API</h3><p>可以通过使用version来实现无锁并发。</p><ul><li>create接口，参数为path、data、flags。<code>create(path, data, flags)</code>，这里flags对应上面ZNode的3种类型</li><li>delete接口，参数为path、version。<code>delete(path, version)</code></li><li>exists接口，参数为path、watch。<code>exists(path, watch)</code></li><li>getData原语，参数为path、version。<code>getData(path, version)</code></li><li>setData原语，参数为path、data、version。<code>setData(path, data, version)</code></li><li>getChildren接口，参数为path、watch。<code>getChildren(path, watch)</code>，可以获取特定znode的子节点</li></ul><h2 id="实现分布式锁" tabindex="-1"><a class="header-anchor" href="#实现分布式锁" aria-hidden="true">#</a> 实现分布式锁</h2><h3 id="简易版" tabindex="-1"><a class="header-anchor" href="#简易版" aria-hidden="true">#</a> 简易版</h3><div class="language-pseudocode line-numbers-mode" data-ext="pseudocode"><pre class="language-pseudocode"><code>Lock:
while(true) {
	if(create(&quot;/lock&quot;, EPHEMERAL)) {
		break;
	}
	if(exists(&quot;/lock&quot;,watch)) {
		wait watch
	}
}
Unlock:
del(&quot;/lock&quot;)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>zookeeper在应对并发创建<code>/lock</code>时能够保证只执行其中一个，所以只会由一个机器拿到锁。同时采用<strong>EPHEMERAL</strong>防止机器掉线后导致死锁。</p><p>在得知自己没有拿到锁后，采用watch机制监听节点变化。</p><p>当锁被删除后，使用watch机制唤醒所有等待的节点，这些节点会进行争夺，再次选出一个节点获取到锁，所以可以看出，当前的锁是<strong>非公平</strong>的。</p>`,31),g=a("code",null,"1000",-1),f={href:"https://cloud.tencent.com/developer/article/2321587",target:"_blank",rel:"noopener noreferrer"},k=o(`<h3 id="优化版" tabindex="-1"><a class="header-anchor" href="#优化版" aria-hidden="true">#</a> 优化版</h3><div class="language-pseudocode line-numbers-mode" data-ext="pseudocode"><pre class="language-pseudocode"><code>Lock:
// 在同一前缀下以临时和有序的特性创建znode
n = create(prefix + &quot;/lock-&quot;, EPHEMERAL | SEQUENTIAL)
// 获取前缀下的所有子节点
C = getChildren(prefix, false)
// 如果当前节点是最小的节点，代表获取到锁，退出
if n is lowest znode in C, exit
// 否则监听当前节点的前一个节点
p = znode in C ordered just before n
if exists(p, true) wait for watch event
goto 5

Unlock
delete(n)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,2);function z(x,_){const n=r("ExternalLinkIcon"),t=r("RouterLink");return s(),l("div",null,[p,a("blockquote",null,[u,a("p",null,[a("a",v,[e("分布式数据一致性综述"),i(n)])]),a("p",null,[a("a",b,[e("线性一致性详解"),i(n)])])]),m,a("p",null,[e("同时，如果有"),g,e("个节点同时获取锁，当第一个节点释放锁后，zookeeper服务器会收到999个请求，随后是998，997....。这被称为羊群效应，对zookeeper服务器是一种很大的负担："),a("a",f,[e("深入解析集群的羊群效应"),i(n)]),e("。")]),k,a("p",null,[e("这样就可以采用类似java中"),i(t,{to:"/code/distribute/mit-6.824/....%5Cback%5Cjava%5Cjuc%5Cjuc.html#AQS"},{default:c(()=>[e("AQS")]),_:1}),e(" 的处理形式，由前一个节点负责唤醒后一个节点。")])])}const q=d(h,[["render",z],["__file","Zookeeper.html.vue"]]);export{q as default};
