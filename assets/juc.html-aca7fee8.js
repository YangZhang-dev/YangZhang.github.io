const l=JSON.parse('{"key":"v-a2774af4","path":"/code/back/java/juc/juc.html","title":"juc","lang":"en-US","frontmatter":{"title":"juc","order":1,"author":"zzys","date":"2023-07-12T00:00:00.000Z","category":["技术成长"],"tags":["juc","java"]},"headers":[{"level":2,"title":"进程与线程","slug":"进程与线程","link":"#进程与线程","children":[{"level":3,"title":"进程和线程","slug":"进程和线程","link":"#进程和线程","children":[]},{"level":3,"title":"并发和并行","slug":"并发和并行","link":"#并发和并行","children":[]},{"level":3,"title":"应用","slug":"应用","link":"#应用","children":[]}]},{"level":2,"title":"Java线程","slug":"java线程","link":"#java线程","children":[{"level":3,"title":"创建运行线程","slug":"创建运行线程","link":"#创建运行线程","children":[]},{"level":3,"title":"线程运行的原理","slug":"线程运行的原理","link":"#线程运行的原理","children":[]},{"level":3,"title":"Thread类常见方法","slug":"thread类常见方法","link":"#thread类常见方法","children":[]},{"level":3,"title":"start vs run","slug":"start-vs-run","link":"#start-vs-run","children":[]},{"level":3,"title":"sleep vs yield","slug":"sleep-vs-yield","link":"#sleep-vs-yield","children":[]},{"level":3,"title":"join","slug":"join","link":"#join","children":[]},{"level":3,"title":"interrupt","slug":"interrupt","link":"#interrupt","children":[]},{"level":3,"title":"主线程和守护线程","slug":"主线程和守护线程","link":"#主线程和守护线程","children":[]},{"level":3,"title":"操作系统层面的五种状态","slug":"操作系统层面的五种状态","link":"#操作系统层面的五种状态","children":[]},{"level":3,"title":"java层面的六种状态","slug":"java层面的六种状态","link":"#java层面的六种状态","children":[]}]},{"level":2,"title":"共享模型之管程","slug":"共享模型之管程","link":"#共享模型之管程","children":[{"level":3,"title":"共享的问题","slug":"共享的问题","link":"#共享的问题","children":[]},{"level":3,"title":"synchronized解决方案","slug":"synchronized解决方案","link":"#synchronized解决方案","children":[]},{"level":3,"title":"变量的线程安全分析","slug":"变量的线程安全分析","link":"#变量的线程安全分析","children":[]},{"level":3,"title":"常见的线程安全类","slug":"常见的线程安全类","link":"#常见的线程安全类","children":[]},{"level":3,"title":"不可变类线程安全性","slug":"不可变类线程安全性","link":"#不可变类线程安全性","children":[]},{"level":3,"title":"Monitor","slug":"monitor","link":"#monitor","children":[]},{"level":3,"title":"wait/notify","slug":"wait-notify","link":"#wait-notify","children":[]},{"level":3,"title":"Park&UnPark","slug":"park-unpark","link":"#park-unpark","children":[]},{"level":3,"title":"状态转换","slug":"状态转换","link":"#状态转换","children":[]},{"level":3,"title":"多把锁","slug":"多把锁","link":"#多把锁","children":[]},{"level":3,"title":"活跃性","slug":"活跃性","link":"#活跃性","children":[]},{"level":3,"title":"ReentrantLock","slug":"reentrantlock","link":"#reentrantlock","children":[]}]},{"level":2,"title":"共享模型之内存","slug":"共享模型之内存","link":"#共享模型之内存","children":[{"level":3,"title":"Java内存模型","slug":"java内存模型","link":"#java内存模型","children":[]},{"level":3,"title":"可见性","slug":"可见性","link":"#可见性","children":[]},{"level":3,"title":"有序性","slug":"有序性","link":"#有序性","children":[]},{"level":3,"title":"原理之volatile","slug":"原理之volatile","link":"#原理之volatile","children":[]},{"level":3,"title":"happens-before原则","slug":"happens-before原则","link":"#happens-before原则","children":[]}]},{"level":2,"title":"共享模型之无锁","slug":"共享模型之无锁","link":"#共享模型之无锁","children":[{"level":3,"title":"CAS与volatile","slug":"cas与volatile","link":"#cas与volatile","children":[]},{"level":3,"title":"为什么无锁的效率高","slug":"为什么无锁的效率高","link":"#为什么无锁的效率高","children":[]},{"level":3,"title":"CAS的特点","slug":"cas的特点","link":"#cas的特点","children":[]},{"level":3,"title":"原子整数","slug":"原子整数","link":"#原子整数","children":[]},{"level":3,"title":"原子引用","slug":"原子引用","link":"#原子引用","children":[]},{"level":3,"title":"原子类型","slug":"原子类型","link":"#原子类型","children":[]},{"level":3,"title":"Unsafe","slug":"unsafe","link":"#unsafe","children":[]}]},{"level":2,"title":"共享模型之不可变","slug":"共享模型之不可变","link":"#共享模型之不可变","children":[{"level":3,"title":"不可变的设计","slug":"不可变的设计","link":"#不可变的设计","children":[]},{"level":3,"title":"保护性拷贝（defensive copy）","slug":"保护性拷贝-defensive-copy","link":"#保护性拷贝-defensive-copy","children":[]},{"level":3,"title":"final原理","slug":"final原理","link":"#final原理","children":[]},{"level":3,"title":"无状态","slug":"无状态","link":"#无状态","children":[]}]},{"level":2,"title":"线程池","slug":"线程池","link":"#线程池","children":[{"level":3,"title":"ThreadPoolExecutor","slug":"threadpoolexecutor","link":"#threadpoolexecutor","children":[]},{"level":3,"title":"Executors类工厂方法","slug":"executors类工厂方法","link":"#executors类工厂方法","children":[]},{"level":3,"title":"线程池方法","slug":"线程池方法","link":"#线程池方法","children":[]},{"level":3,"title":"创建线程的数量","slug":"创建线程的数量","link":"#创建线程的数量","children":[]},{"level":3,"title":"任务调度线程池","slug":"任务调度线程池","link":"#任务调度线程池","children":[]},{"level":3,"title":"执行任务异常","slug":"执行任务异常","link":"#执行任务异常","children":[]},{"level":3,"title":"fork/join","slug":"fork-join","link":"#fork-join","children":[]}]},{"level":2,"title":"JUC","slug":"juc","link":"#juc","children":[{"level":3,"title":"AQS","slug":"aqs","link":"#aqs","children":[]},{"level":3,"title":"ReentrantLock原理（理解）","slug":"reentrantlock原理-理解","link":"#reentrantlock原理-理解","children":[]},{"level":3,"title":"读写锁","slug":"读写锁","link":"#读写锁","children":[]}]}],"git":{"updatedTime":1695991935000,"contributors":[{"name":"YangZhang","email":"2803436425@qq.com","commits":1}]},"filePathRelative":"code/back/java/juc/juc.md","copyright":{"author":"YangZhang","license":"MIT Licensed | Copyright © 2023-present YangZhang"}}');export{l as data};
