import{_ as e,r as s,o as t,c as o,a,b as c,d as r,e as p}from"./app-20538318.js";const l={},i=p(`<h2 id="jdk动态代理-不实现接口就不能做代理了吗-为什么" tabindex="-1"><a class="header-anchor" href="#jdk动态代理-不实现接口就不能做代理了吗-为什么" aria-hidden="true">#</a> JDK动态代理，不实现接口就不能做代理了吗，为什么</h2><p>是的，如果要使用JDK动态代理必须要创建接口，在JDK1.8下的Proxy类中有一个静态内部类ProxyClassFactory，其中的apply方法是用来生产Proxy的，中间有一段代码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token comment">/*
 * Verify that the Class object actually represents an
 * interface.
 */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>interfaceClass<span class="token punctuation">.</span><span class="token function">isInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>
        interfaceClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; is not an interface&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果传入的Class不是interface类型，会直接抛出异常。</p><h2 id="threadlocal使用场景原理" tabindex="-1"><a class="header-anchor" href="#threadlocal使用场景原理" aria-hidden="true">#</a> ThreadLocal使用场景原理</h2><p>在项目中主要使用ThreadLocal保存线程的本地变量，比如可以在拦截器中放入用户id，之后都可以很方便的取出id，但是要注意在拦截器的后置处理中一定要将其remove，不然会导致内存泄漏。</p><p>虽然前面说的时使用ThreadLocal保存线程本地变量，但是我更倾向于把它称作一个钩子，利用它可以将ThreadLocalMap中钩出想要的数据，ThreadLocalMap是Thread的一个属性，它是懒加载的，只有当我们第一次访问时才会创建。</p><p>ThreadLocalMap中的Entry是以当前的ThreadLocal为key，设置的值为value存放的，对于不同的线程，使用相同的ThreadLocal去获取数据，获取到的是Thread自己的ThreadLocalMap内部的Entry，也就实现了线程本地变量。向外保持了很好的封装性。</p><h2 id="java为什么不可以多继承" tabindex="-1"><a class="header-anchor" href="#java为什么不可以多继承" aria-hidden="true">#</a> Java为什么不可以多继承</h2><p>声明多继承（支持）、实现多继承（不支持）</p>`,10),d={href:"https://www.zhihu.com/question/24317891",target:"_blank",rel:"noopener noreferrer"};function u(h,k){const n=s("ExternalLinkIcon");return t(),o("div",null,[i,a("p",null,[a("a",d,[c("Java 为什么不支持多继承？"),r(n)])])])}const m=e(l,[["render",u],["__file","Java.html.vue"]]);export{m as default};
