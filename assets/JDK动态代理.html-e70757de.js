import{_ as n,o as s,c as a,e}from"./app-20538318.js";const t={},p=e(`<h2 id="静态代理" tabindex="-1"><a class="header-anchor" href="#静态代理" aria-hidden="true">#</a> 静态代理</h2><p>每次谈到动态代理，都需要把静态代理拿出来诋毁一番。静态代理，顾名思义就是需要我们静态的提供一个代理类，创建代理对象，实现增强操作。</p><p>代理是一种模式，提供了对目标对象的间接访问方式，即通过代理访问目标对象。如此便于在目标实现的基础上增加额外的功能操作，前拦截，后拦截等，以满足自身的业务需求。</p><h3 id="实现" tabindex="-1"><a class="header-anchor" href="#实现" aria-hidden="true">#</a> 实现</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>├─TargetService.java   <span class="token comment"># 接口</span>
├─TestStaticProxy.java  <span class="token comment"># 测试类</span>
├─impl
<span class="token operator">|</span>  ├─TargetProxy.java   <span class="token comment"># 静态代理类</span>
<span class="token operator">|</span>  └TargetServiceImpl.java  <span class="token comment"># 目标类</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TargetProxy</span> <span class="token keyword">implements</span> <span class="token class-name">TargetService</span> <span class="token punctuation">{</span>
    <span class="token comment">// private 防止外界修改，final防止子类修改</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">TargetService</span> targetService<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">TargetProxy</span><span class="token punctuation">(</span><span class="token class-name">TargetService</span> targetService<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>targetService <span class="token operator">=</span> targetService<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;before do something&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        targetService<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;after do something&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们会发现，每当我们需要为一个接口下的实现类做代理，就需要一个新的代理类，这确实也体现了静态的特点。其实，所有的代理类大体都是相似的，不同的是<strong>增强逻辑</strong>以及<strong>需要被代理的类</strong>。我们能不能不去手动新建代理类，直接通过这两个就获取到代理对象呢？</p><h2 id="jdk动态代理" tabindex="-1"><a class="header-anchor" href="#jdk动态代理" aria-hidden="true">#</a> JDK动态代理</h2><p>我们知道，创建对象的过程：<code>java代码--&gt;class字节码--&gt;Class对象--&gt;实际对象</code>。我们不想编写java代码，也就意味着class字节码是不存在了，需要凭空出现一个Class对象，并且这个对象还需要有我们希望被代理对象的关键方法（继承自接口的方法）。</p><p>那么就要想方法拿到关键方法的信息，有两种途径：</p><ul><li>一是直接通过需要被代理的对象直接获取（CGLib动态代理）</li><li>二是通过代理接口获取（JDK动态代理）</li></ul><p>通过实验能够发现，接口中不存在构造器的方法信息，只存在方法的信息，那么我们就可以考虑从接口获取代理对象。</p><h3 id="proxy" tabindex="-1"><a class="header-anchor" href="#proxy" aria-hidden="true">#</a> Proxy</h3><p>在<code>java.lang.reflect</code>中有名叫<code>Proxy</code>的类，其中：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">getProxyClass</span><span class="token punctuation">(</span><span class="token class-name">ClassLoader</span> loader<span class="token punctuation">,</span>
                                     <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> interfaces<span class="token punctuation">)</span>
    <span class="token keyword">throws</span> <span class="token class-name">IllegalArgumentException</span>
<span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> intfs <span class="token operator">=</span> interfaces<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">SecurityManager</span> sm <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>sm <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">checkProxyAccess</span><span class="token punctuation">(</span><span class="token class-name">Reflection</span><span class="token punctuation">.</span><span class="token function">getCallerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> loader<span class="token punctuation">,</span> intfs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token function">getProxyClass0</span><span class="token punctuation">(</span>loader<span class="token punctuation">,</span> intfs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此方法需要我们传入一个类加载器以及接口的Class信息，在方法中调用Class的clone方法生成了全新的Class对象，这样就完成了我们的诉求，即没有字节码，创建全新的Class对象，总结来说就是<strong>用Class造Class，即用接口Class造出一个代理类Class，然后把我们接口中的所有方法复制过去</strong>。</p><p>我们调用此方法，获取Class对象，同时尝试获取构造器。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> proxyClass <span class="token operator">=</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">getProxyClass</span><span class="token punctuation">(</span><span class="token class-name">TargetService</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token class-name">TargetService</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> constructor <span class="token operator">=</span> proxyClass<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span><span class="token class-name">InvocationHandler</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// public com.sun.proxy.$Proxy0(java.lang.reflect.InvocationHandler)</span>

<span class="token comment">// getMethod()中有一条：public final void com.sun.proxy.$Proxy0.doSomething()</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以发现，JDK底层不仅为我们构造好了代理对象，同时，为我们创建了一个有参构造，其中需要传入<code>InvocationHandler</code>类，同时，我们需要的同名目标方法也已经存在。</p><p>那么我们就顺着这个构造函数创建代理对象：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">TargetService</span> service <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">TargetService</span><span class="token punctuation">)</span>constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InvocationHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
        <span class="token class-name">TargetServiceImpl</span> targetService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TargetServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Object</span> res <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">TargetServiceImpl</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
service<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>传入一个匿名类，实现它的invoke方法，其中第一个参数是代理对象实例，一般不用。第二个是调用的方法，第三个是传入的参数。</p><p>当我们调用代理类的方法的同名方法<code>doSomething</code>时，内部调用了<code>InvocationHandler</code>的<code>invoke</code>方法，里面就是我们自己的逻辑了。</p><h3 id="问题" tabindex="-1"><a class="header-anchor" href="#问题" aria-hidden="true">#</a> 问题</h3><p><code>Proxy</code>是怎么强转为<code>TargetService</code>的呢？实际上<code>$Proxy0</code>是运行时才存在的类，它会被JVM底层动态的实现TargetService接口，所以强转不会报错。</p><p>同时，为什么调用Proxy的同名方法就可以实现调用增强代码呢？还记的在获取构造器是，我们匹配到了含有一个<code>InvocationHandler</code>参数的构造器，所以在下面的构造方法中，<code>invocationHandler</code>就被父类<code>Proxy</code>所赋值给<code>h</code>属性，我们就可以在<code>$Proxy0</code>中调用<code>this.h</code>来执行增强代码了。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 1.自动实现目标接口，所以代理对象可以转成Calculator</span>
<span class="token keyword">final</span> <span class="token keyword">class</span> $<span class="token class-name">Proxy0</span> <span class="token keyword">extends</span> <span class="token class-name">Proxy</span> <span class="token keyword">implements</span> <span class="token class-name">Proxy<span class="token punctuation">.</span>TergetService</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Method</span> m3<span class="token punctuation">;</span>

    <span class="token keyword">public</span> $<span class="token class-name">Proxy0</span><span class="token punctuation">(</span><span class="token class-name">InvocationHandler</span> invocationHandler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>invocationHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token comment">// 2.获取目标方法Method</span>
        m3 <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">&quot;com.zzys.demo.Proxy$Calculator&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">&quot;doSomething&quot;</span><span class="token punctuation">,</span> 可以有参数（<span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">TYPE</span>）<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> n2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 3.通过InvocationHandler执行方法</span>
        <span class="token comment">//   this：就是$Proxy0的实例，所以是代理对象，不是目标对象</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">.</span>h<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> m3<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>n<span class="token punctuation">,</span> n2<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,27),c=[p];function o(l,i){return s(),a("div",null,c)}const r=n(t,[["render",o],["__file","JDK动态代理.html.vue"]]);export{r as default};
