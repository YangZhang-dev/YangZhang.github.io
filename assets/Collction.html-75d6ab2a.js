import{_ as a,o as s,c as n,e}from"./app-20538318.js";const t={},p=e(`<h2 id="map" tabindex="-1"><a class="header-anchor" href="#map" aria-hidden="true">#</a> Map</h2><p>map常见的是HashMap、TreeMap、HashTable和ConcurrentHashMap。其中HashTable不常用，单线程使用HashMap，多线程使用ConcurrentHashMap。</p><h3 id="hashmap的长度为什么是2的幂次方" tabindex="-1"><a class="header-anchor" href="#hashmap的长度为什么是2的幂次方" aria-hidden="true">#</a> HashMap的长度为什么是2的幂次方</h3><p>因为hashCode的范围是<code>-2^31~2^31-1</code>，加起来大概40亿的映射空间，内存存放不下，所以我们需要对长度进行取模处理。并且在<code>n == 2^n</code>的情况下，使用<code>hashCode &amp; (n - 1)</code>是和<code>hashCode % n</code>相等的，加快运算速度。</p><h3 id="hashmap的hash方法" tabindex="-1"><a class="header-anchor" href="#hashmap的hash方法" aria-hidden="true">#</a> HashMap的hash方法</h3><p>hash方法是用来在一个元素加入map时，确定其位置时使用的方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>   <span class="token comment">// JDK1.8：</span>
	<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> h<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果传入的对象是空，那么直接返回0。否则进行以下计算：</p><p>获取对象的hashcode并和hashcode的算术右移十六位进行异或。这两步是进行了扰动计算，在put之前调用此方法，目的是为了将高十六位也加入到特征计算中，防止在hash位置时只有低位的特征，尽可能的减少哈希冲突的概率，同时采用异或是为了尽可能的保证高十六位的特性，避免像与和或运算那样将计算结果靠拢0，1。</p><h3 id="hashmap的底层实现" tabindex="-1"><a class="header-anchor" href="#hashmap的底层实现" aria-hidden="true">#</a> HashMap的底层实现</h3><p>JDK1.7之前是使用拉链法，即数组加链表解决哈希冲突，每当新插入的元素和旧的元素发生哈希冲突时，就插入到对应链表中。</p><p>JDK1.8后，在链表插入时，如果个数大于8个元素，会将链表转化为红黑树结构（中间会有一次判断，如果数组的长度小于64，那么会先选择扩容，而不是转换），减少搜索时间。<code>treeifyBin</code>是将链表转换为红黑树的方法</p><h3 id="concurrenthashmap和hashtable" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap和hashtable" aria-hidden="true">#</a> ConcurrentHashMap和HashTable</h3><p>两者都实现了线程安全，Hash是在所有的方法上加入了synchronized，当一个线程插入时，其余线程无法插入，效率很低。</p><p>在JDK1.7前，ConcurrentHashMap是对底层数组进行了分段，对段数组进行加锁处理</p><h2 id="arraylist" tabindex="-1"><a class="header-anchor" href="#arraylist" aria-hidden="true">#</a> ArrayList</h2><p>线程不安全，底层是<code>Object[]</code>，尾插<code>O(1)</code>，头插和任意插入是<code>O(n)</code>，实现了<code>RandomAccess</code>接口支持随机访问，每次扩容有可能会预留一定的空间，以空间换时间，减少分配次数。</p><h3 id="arraylist-可以添加-null-值吗" tabindex="-1"><a class="header-anchor" href="#arraylist-可以添加-null-值吗" aria-hidden="true">#</a> ArrayList 可以添加 null 值吗？</h3><p>可以，但不建议，可能忘记判空处理</p><h3 id="arraylist核心源码" tabindex="-1"><a class="header-anchor" href="#arraylist核心源码" aria-hidden="true">#</a> ArrayList核心源码</h3><p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/553856791c3ee1774ca7167f1f8de27f.jpg" alt="" loading="lazy"></p>`,21),c=[p];function o(r,h){return s(),n("div",null,c)}const d=a(t,[["render",o],["__file","Collction.html.vue"]]);export{d as default};
