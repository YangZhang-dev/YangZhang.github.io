import{_ as e,o as t,c as a,e as i}from"./app-20538318.js";const r={},n=i(`<p>frangipani是一个分布式下的文件系统，它的初衷是运行在共享不太频繁的组织中，例如工程师每个人都专注自己的文档，可能会共享，但是没有那么频繁。它提供了很高的性能（操作在本地内存），以及分布式的崩溃恢复。</p><h2 id="简述" tabindex="-1"><a class="header-anchor" href="#简述" aria-hidden="true">#</a> 简述</h2><p>Frangipani中<strong>没有专门的file server</strong>角色，每个client本身就作为file server，因为client本身运行file server code。</p><p>这里所有的client共享一个<strong>虚拟磁盘(<strong>virtual disk)，这个虚拟磁盘内部使用</strong>Petal</strong>实现，由数个机器构成，机器复制磁盘块(disk blocks)，内部通过Paxos共识算法保证操作按正确顺序应用等。</p><p>虚拟磁盘对外的接口是read块(read block)或write块(write block)，看上去就像普通的磁盘。</p><p>在Frangipani这种设计下，复杂的设计更多在于client。可以通过增加工作站(workstation)数量来拓展文件系统。通过增加client数量，每个client都可以在自己的文件系统上运行，许多繁重的计算都可以在client机器上完成，根本<strong>不涉及</strong>任何文件系统服务器。而传统的网络文件系统的性能瓶颈往往出现在文件服务器。</p><h2 id="挑战" tabindex="-1"><a class="header-anchor" href="#挑战" aria-hidden="true">#</a> 挑战</h2><p>正如涉及目标所述，Frangipani的涉及面临下面的难点：</p><p>假设WS1工作站1执行read f的操作，之后通过本地cache对f通过vi进行操作。这时需要考虑几个可能发生的场景如何处理：</p><ol><li><p>WS2 cat f</p><p>工作站2查看f文件，这时需要通过**缓存一致性(cache conference)**确保工作站2能看到正确的内容。</p></li><li><p>WS1创建d/f，WS2创建d/g</p><p>需要保证WS1创建d目录下的f文件，以及WS2创建d目录下的g文件时，双方不会因为创建目录导致对方的文件被覆盖或消失等问题。这里需要**原子性(atomicity)**保证操作之间不会互相影响。</p></li><li><p>WS1 crash during FS op</p><p>工作站1进行复杂的文件操作时发生崩溃crash。需要**崩溃恢复(crash recovery)**机制。</p></li></ol><h2 id="缓存一致性" tabindex="-1"><a class="header-anchor" href="#缓存一致性" aria-hidden="true">#</a> 缓存一致性</h2><p>Frangipani主要通过lock锁机制实现缓存一致性。</p><table><thead><tr><th style="text-align:center;">file inode</th><th style="text-align:center;">owner</th></tr></thead><tbody><tr><td style="text-align:center;">f</td><td style="text-align:center;">ws1</td></tr><tr><td style="text-align:center;">g</td><td style="text-align:center;">ws1</td></tr><tr><td style="text-align:center;">h</td><td style="text-align:center;">ws2</td></tr></tbody></table><p>锁服务器(lock server)维护一张表table，里面维护每个file对应的inode编号，以及锁的owner拥有者对应哪个工作站。这里lock server本身是一个分布式服务，可以想象成类似zookeeepr，其提供加锁/解锁接口，且服务具有容错性。</p><table><thead><tr><th style="text-align:center;">file inode</th><th style="text-align:center;">State</th></tr></thead><tbody><tr><td style="text-align:center;">f</td><td style="text-align:center;">busy</td></tr><tr><td style="text-align:center;">g</td><td style="text-align:center;">idle</td></tr></tbody></table><p>同时，工作站自身也需要维护一张table，table维护lock对应的状态，比如f文件锁对应的状态为busy，g文件锁对应的状态为idle，表示g这一时刻没有被修改。这里idle状态的锁被称为<strong>粘性锁(sticky lock)</strong>。注意本地的锁和服务器的锁是分开的。</p><p>缓存文件之前，需要先获取锁，通过锁来保证只有一端能够更改文件内容，自然的就保证了缓存的一致性。</p><h2 id="协议" tabindex="-1"><a class="header-anchor" href="#协议" aria-hidden="true">#</a> 协议</h2><p>在WS和LS之间通信，会使用4种消息：</p><ul><li>请求锁，requesting a lock</li><li>授予锁，granting a lock</li><li>撤销锁，revoking a lock</li><li>释放锁，releasing a lock</li></ul><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/6183099d914ad5d1d32df074a1ceb9db.png" alt="image-20231114215553182" style="zoom:50%;"><h2 id="原子性" tabindex="-1"><a class="header-anchor" href="#原子性" aria-hidden="true">#</a> 原子性</h2><div class="language-pseudocode line-numbers-mode" data-ext="pseudocode"><pre class="language-pseudocode"><code>acquire(&quot;d&quot;) // 获取目录d的锁
    create(&quot;f&quot; ,....) // 创建文件f
    acquire(&quot;f&quot;) // 获取文件f的inode锁
        allocate inode // 分配f文件对应的inode
        write inode // 写inode信息
        update directory (&quot;f&quot;, ...) // 关联f对应的inode到d目录下
    release(&quot;f&quot;) // 释放f对应的inode锁
release(&quot;d&quot;) // 释放目录d对应的锁
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="崩溃恢复" tabindex="-1"><a class="header-anchor" href="#崩溃恢复" aria-hidden="true">#</a> 崩溃恢复</h2><p>Frangipani的崩溃恢复的本质是使用了WAL技术，通过预先写入日志，保证在更新时宕机可以被恢复。</p><p>当复制发生时(即LS向WS发送revoke撤销锁后，WS需要将文件变更同步到Petal)，经过以下流程：</p><ol><li>将本地的log发送到Petal。</li><li>发送更新块到Petal。</li><li>释放锁。</li></ol><p>每台Frangipani服务器都有log日志，log中的log entry拥有<strong>序列号</strong>(sequence number)。<strong>log entry中存放更新数组(array of updates)</strong>，用于描述文件系统操作，包含以下内容：</p><ul><li>需要更新的块号(block number that needs to be updated),对应inode编号</li><li><strong>版本号</strong>(version number),</li><li>块编号对应的新字节数据(new bytes)</li></ul><p>实际上，<strong>文件数据(file data)写入不会通过日志</strong>，而是直接传递给Petal。通过日志的更新是<strong>元数据</strong>(meta data)更改。元数据的含义是关于file文件的信息，比如inode、目录等，这些会通过log。应用级数据，实际构成文件的文件块直接写入到Petal，而不需要通过log。</p><blockquote><p>Unix设计： 对于需要原子写文件的场景，通常人们通过先将所有数据写入一个临时文件，然后做一个<strong>原子重命名</strong>（atomic rename），使得临时文件编程最终需要的文件</p></blockquote><h2 id="崩溃场景分析" tabindex="-1"><a class="header-anchor" href="#崩溃场景分析" aria-hidden="true">#</a> 崩溃场景分析</h2><h3 id="写入日志前" tabindex="-1"><a class="header-anchor" href="#写入日志前" aria-hidden="true">#</a> 写入日志前</h3><p>数据丢失</p><h3 id="写入日志后" tabindex="-1"><a class="header-anchor" href="#写入日志后" aria-hidden="true">#</a> 写入日志后</h3><p>假设写log到Petal后WS1崩溃，此时WS1占有log，如果WS2想要获取同一个文件inode的lock，LS会等待WS1的lock租约过期后，<strong>要求剩余的WS的recovery damon读取WS1的log，并应用log中记录的操作</strong>。等待damon工作完成后，LS重新分配锁，即授予WS2锁。</p><h3 id="写入日志中" tabindex="-1"><a class="header-anchor" href="#写入日志中" aria-hidden="true">#</a> 写入日志中</h3><p>文件中包括前缀，如果写log中崩溃，那么文件的校验和检验就不会通过，recovery demon会停止在检验和不通过的记录之前。</p><h3 id="版本号" tabindex="-1"><a class="header-anchor" href="#版本号" aria-hidden="true">#</a> 版本号</h3><p>在写入后，未写入日志前的崩溃，在recovery damon的恢复中，可能会出现操作被覆盖的情况，所以对每一个inode引入了version属性：</p><ol><li>WS1在log中记录<code>delete (&#39;d/f&#39;)</code>，删除d目录下的f文件。log的版本号假设为10</li><li>WS2在log中记录<code>create(&#39;d/f&#39;)</code>，log的版本号为11（因为<strong>锁保证了log的版本号是完全有序的</strong>）</li><li>WS1崩溃</li><li>WS3观察到WS1崩溃，为WS1启动一个recovery demon，准备执行WS1的log记录<code>delete(&#39;d/f&#39;)</code>，<strong>但是发现Petal中已应用的log对应的version版本号为11，高于log或inode的version，准备重放的log的version为10，小于等于11，所以demon会放弃重放这个log</strong>。</li></ol>`,41),l=[n];function d(o,s){return t(),a("div",null,l)}const g=e(r,[["render",d],["__file","Frangipani.html.vue"]]);export{g as default};
