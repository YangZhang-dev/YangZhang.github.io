import{_ as i,r as s,o as n,c as r,a as e,b as a,d as l,w as c,e as t}from"./app-20538318.js";const d={},u=t('<p>本章对分布式有了一个简单的介绍，同时讲解了Google开源的MapReduce。</p><h2 id="分布式系统简介" tabindex="-1"><a class="header-anchor" href="#分布式系统简介" aria-hidden="true">#</a> 分布式系统简介</h2><p>分布式系统就是由若干只能通过网络进行通信交互的系统构成的系统。</p><h3 id="为什么使用分布式系统" tabindex="-1"><a class="header-anchor" href="#为什么使用分布式系统" aria-hidden="true">#</a> 为什么使用分布式系统</h3><ul><li>sharing：系统之间资源共享</li><li>大量数据的并行计算</li><li>提高系统容错（如果是单机系统，一旦出故障即服务完全不可用）</li></ul><h3 id="挑战" tabindex="-1"><a class="header-anchor" href="#挑战" aria-hidden="true">#</a> 挑战</h3><ul><li>高并发场景</li><li>机器故障（网络分区）</li><li>性能</li></ul><h3 id="基础设施" tabindex="-1"><a class="header-anchor" href="#基础设施" aria-hidden="true">#</a> 基础设施</h3><ul><li>存储（storage）：文件系统，kv存储</li><li>计算（computation）：计算框架，如MapReduce</li><li>通信（communication）：网络通信，如RPC</li></ul><h3 id="主题" tabindex="-1"><a class="header-anchor" href="#主题" aria-hidden="true">#</a> 主题</h3>',10),h=e("li",null,"高可用（availability）：复制技术",-1),p=e("li",null,[a("一致性（consistency） "),e("ul",null,[e("li",null,"强一致性：多个机器的行为像串行一样。"),e("li",null,"最终一致性：只保证最后一个行为之后机器的状态一致，过程不保证")])],-1),f=e("li",null,[a("性能（performance） "),e("ul",null,[e("li",null,"吞吐量（throughput）"),e("li",null,"低延迟（latency）：尾部延迟（tail latency）")])],-1),m=t(`<p>分布式系统无法同时兼顾三点，一般的分布式系统会根据应用场景选择其中的两点满足。</p><h2 id="mapreduce" tabindex="-1"><a class="header-anchor" href="#mapreduce" aria-hidden="true">#</a> MapReduce</h2><p><strong>MapReduce</strong> 就是为了编写在普通机器上运行的大规模并行数据处理程序而抽象出来的编程模型，为解决<strong>多机并行协同</strong>,<strong>网络通信,处理错误,提高执行效率</strong> 等通用性问题的一个编程框架。</p><h3 id="逻辑流程" tabindex="-1"><a class="header-anchor" href="#逻辑流程" aria-hidden="true">#</a> 逻辑流程</h3><p>程序员通过编写无状态的<code>map</code>和<code>reduce</code>函数实现分布式的数据处理，由MapReduce来实现分布式的细节。</p><p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/2441fb4db13f788cf4f76fa72eb955a3.png" alt="" loading="lazy"></p><p>上图是MapReduce的最常见应用，采集文件中单词的个数。其中用户只需要编写Map函数，切割文件，获取文件单词个数，以及编写Reduce函数，将values累加即可。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>map(String key, String value):
	// key: document name
	// value: document contents
	for each word w in value:
		EmitIntermediate(w, &quot;1&quot;);
reduce(String key, Iterator values):
	// key: a word
	// values: a list of counts
	int result = 0;
	for each v in values:
		result += ParseInt(v);
	Emit(AsString(result));
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中Shuffle是将每个Map worker生成的k/v对按需排列，以便Reduce使用。</p><p>我们可以将上述流程抽象为以下模型：</p><ul><li>map: (k1,v1) -&gt; list(k2,v2)</li><li>reduce: (k2,list(v2)) -&gt; list(v2)</li></ul><p>其中可以加上一层shuffle：</p><ul><li>shuffle: list(k2,v3) -&gt; (k2,list(v2))</li></ul><h3 id="物理流程" tabindex="-1"><a class="header-anchor" href="#物理流程" aria-hidden="true">#</a> 物理流程</h3><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/c26cce3bc7bbea604b0cf8ebf3cba20e.png" alt="image-20230917185135866" style="zoom:67%;"><p>上面的图片是MapReduce-paper<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup>的图片。</p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/fccdaf0f73cd0d08ec07d293eb2756c0.svg" style="zoom:67%;"><p>上面的图片出自MapReduce论文导读<sup class="footnote-ref"><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2"></a></sup>。</p><p>注意，MapReduce在这篇论文中是和GFS联合起来用的，所以很多地方不需要进行网络通信，只在Reduce worker从中间文件中拉取数据时用到了RPC。</p><h3 id="容错" tabindex="-1"><a class="header-anchor" href="#容错" aria-hidden="true">#</a> 容错</h3><h4 id="worker容错" tabindex="-1"><a class="header-anchor" href="#worker容错" aria-hidden="true">#</a> worker容错</h4><p>由于worker是无状态的，所以一旦master无法连接上worker，就认为出现了故障，将其他完成任务的同类型worker调用起来再次执行该任务。</p><h4 id="master" tabindex="-1"><a class="header-anchor" href="#master" aria-hidden="true">#</a> master</h4><p>一般master只有一个，不会认为它出现故障，一旦出现故障，一般的会选择重启整个任务。</p><h3 id="掉队机制" tabindex="-1"><a class="header-anchor" href="#掉队机制" aria-hidden="true">#</a> 掉队机制</h3><p>同尾部延迟，如果一个worker能力较弱，同时又分配了较为多的任务，有可能影响到整个MapReduce，所以采用了backup task机制，存在一些备用worker执行剩下的任务。</p><blockquote><p>MapReduce还有很多其他的机制，可以参见MapReduce-paper<sup class="footnote-ref"><a href="#footnote1">[1:1]</a><a class="footnote-anchor" id="footnote-ref1:1"></a></sup>，以及MapReduce论文导读<sup class="footnote-ref"><a href="#footnote2">[2:1]</a><a class="footnote-anchor" id="footnote-ref2:1"></a></sup>。</p></blockquote><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="footnote1" class="footnote-item"><p>http://nil.csail.mit.edu/6.824/2021/papers/mapreduce.pdf <a href="#footnote-ref1" class="footnote-backref">↩︎</a> <a href="#footnote-ref1:1" class="footnote-backref">↩︎</a></p></li><li id="footnote2" class="footnote-item"><p>https://hardcore.feishu.cn/docs/doccnxwr1i2y3Ak3WXmFlWLaCbh <a href="#footnote-ref2" class="footnote-backref">↩︎</a> <a href="#footnote-ref2:1" class="footnote-backref">↩︎</a></p></li></ol></section>`,29);function b(v,g){const o=s("RouterLink");return n(),r("div",null,[u,e("ul",null,[e("li",null,[a("容错（fault failure） "),e("ul",null,[h,e("li",null,[a("恢复（recoverability）：日志（redo），事务，参见"),l(o,{to:"/code/basic/ostep/ostep-persistence.html"},{default:c(()=>[a("ostep-persistence")]),_:1}),a("中的崩溃日志一章。")])])]),p,f]),m])}const _=i(d,[["render",b],["__file","Introduction-MapReduce.html.vue"]]);export{_ as default};
