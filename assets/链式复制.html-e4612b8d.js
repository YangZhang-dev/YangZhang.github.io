import{_ as r,r as o,o as n,c as s,a as i,b as a,d as t,e}from"./app-20538318.js";const p={},h=i("h2",{id:"复制状态机-rsm",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#复制状态机-rsm","aria-hidden":"true"},"#"),a(" 复制状态机（RSM）")],-1),c=e("<p>一个状态机开始于给定的<strong>开始状态</strong>。每个收到的输入都通过<strong>过渡方程</strong>和<strong>输出方程</strong>来产生一个<strong>新的状态</strong>以及<strong>相应的输出</strong>。这个新的状态会一直<strong>保持</strong>到下一个输入到达，产生的输出会传递给相应的接收者。</p>",1),d={href:"https://zhuanlan.zhihu.com/p/339156677",target:"_blank",rel:"noopener noreferrer"},g=e('<p>这里介绍了两种创建复制状态机的方式：</p><ul><li><p>分布式共识算法：利用Paxos、Raft、ZAB等分布式共识算法，保证多副本之间的一致性。</p></li><li><p>Configuration service + P/B replication(primary backup replication)：一个配置服务器（为了可用性可能运行这分布式共识算法）+ 业务服务器（主备复制）</p></li></ul><p>通常采用第二个方式：</p><ul><li>复制服务在状态state维护的<strong>成本较低</strong>，一般需要维护的<strong>数据量很少</strong></li><li>主备复制则主要负责大量的数据复制工作</li></ul><h2 id="链式复制" tabindex="-1"><a class="header-anchor" href="#链式复制" aria-hidden="true">#</a> 链式复制</h2>',5),S={href:"https://zhuanlan.zhihu.com/p/533384629",target:"_blank",rel:"noopener noreferrer"},u=e('<p>链式复制是主备复制的一种实现方案，它由如下特点：</p><ul><li>读和写都只涉及不同的两个服务器。</li><li>恢复方案简单。</li><li>线性一致。</li></ul><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/feb0c784ea0fe70c4ac19a4bde148f2b.png" alt="image-20231114202331686" style="zoom:33%;"><p>通过一个配置服务(configuration service)记录链式连接的节点信息，记录当前的节点信息，维护节点状态。 如果需要更高的可用性（容错性），可以增加链中的节点数量。</p><p>写请求流程：</p><ol><li>client向系统发起write请求，<strong>写请求</strong>总是会发送到链中的<strong>head</strong>节点服务器</li><li>head节点生成log等，通过storage稳定存储更新相关state状态，然后传递操作到下一个节点</li><li>下一个节点同样更新自己storage中的state状态，然后向下一个节点传递操作</li><li>直到最后一个tail尾节点，修改storage中的状态后，向client回应确认信息。</li></ol><p><strong>tail尾节点就是提交点(commit point)，后续读取总是从tail尾节点获取</strong>。所有的请求只有到达最后一个服务器后才能被读取，而所有的请求都是按照到达顺序从head到tail依次应用（TCP保证），这样就提供了线性一致性。任何client发起读请求，都会请求tail节点，而tail节点会立即响应。</p><h3 id="崩溃" tabindex="-1"><a class="header-anchor" href="#崩溃" aria-hidden="true">#</a> 崩溃</h3><p>节点的三种状态：头节点，尾节点，中间节点。所有的故障恢复都可以归结于三种情况。假设有：<code>S1-&gt;S2-&gt;s3</code>。</p><ol><li><p>头节点故障（处理最简单）</p><p>假设client请求head时，head崩溃了。那么这里S1未向下同步的log记录可以丢弃，因为还没有真正commit。此时，配置服务器得知S1宕机后，会通知S2、S3，宣布S2称为新的head，而S1被抛弃。之后client请求失败后会重试，请求新的head，S2节点。</p></li><li><p>中间节点故障（处理相对复杂）</p><p>类似的，S2故障后，某一时刻配置服务器通知S1和S3需要组成新的链。并且由于S3可能还没有和S1同步到最新状态（因为有些同步log可能还在S2没有下发，或者本身S2也没有完全同步到S1的l信息），所以还需要额外进行同步流程，将S3同步到和S1一致的状态。</p></li><li><p>尾节点故障（处理相对简单）</p><p>S3故障后，配置服务器通知S1、S2组成新链，其中S2成为新的tail。client可以从配置服务器知道S2是新tail。其他的流程基本没变动。</p></li></ol><h3 id="新增" tabindex="-1"><a class="header-anchor" href="#新增" aria-hidden="true">#</a> 新增</h3><p>在tail添加新replica最简单，大致流程如下：</p><ol><li>假设原tail节点S2下新增S3节点，此时client依旧和原tail节点S2交互</li><li>S2会持续将同步信息传递给S3（全量），并且记录哪些log已经同步到S3</li><li>由于全量更新需要很长的时间，所以S2会记录一个更新列表。</li><li>当S3全量更新完成后，向S2发出请求，S2响应并且将更新列表一同传给S3。</li><li>配置服务设置S3为新tail</li><li>后续client改成请求tail节点获取读写响应（client可以通过配置服务知道谁是head、tail）</li></ol><h3 id="并行读优化" tabindex="-1"><a class="header-anchor" href="#并行读优化" aria-hidden="true">#</a> 并行读优化</h3><p>由于链式复制中，只需要tail响应read请求，这里可以做一些优化的工作，进一步提高read吞吐量。</p><p>思路是进行拆分(split)对象，论文中称之为<strong>volume</strong>，将对象拆分到多个链中(splits object across many chain)。</p><p>例如，现在有3个节点S1～S3，我们可以构造3个Chain链：</p><ul><li>Chain1：S1、S2、S3 (tail)</li><li>Chain2：S2、S3、S1 (tail)</li><li>Chian3：S3、S1、S2 (tail)</li></ul><p>注意这里一共只有三个服务器，并不是九个。</p><p>这里可以通过配置服务进行一些数据分片shard操作。如果数据被均匀write到Chain1～Chain3，那么读操作可以并行地命中不同的shards，均匀分布下，读吞吐量(read throughput)会线性增加，理想情况下这里能得到3倍的吞吐量。</p><p>拆分(split)的好处：</p><ol><li>得到扩展(scale)，read<strong>吞吐量提高</strong>(shard越多，chain越多，read吞吐量理论上越高)</li><li><strong>保持线性一致性</strong>(linearizability)</li></ol><h2 id="和raft相比" tabindex="-1"><a class="header-anchor" href="#和raft相比" aria-hidden="true">#</a> 和Raft相比</h2><p>从复制的角度出发，比较一下链式复制CR(Chain Replication)和Raft。</p><p>CR比起Raft的优势：</p><ul><li><p>CR拆分请求RPC负载到head和tail</p><p>前面说过CR的head负责接收write请求，而tail节点负责响应wrtie请求和接收并响应read请求。不必像Raft还需要通过leader完成write、read请求</p></li><li><p>head头节点仅发送update一次</p><p>不同于Raft的leader需要向其他所有followers都发送update，CR的head节点只需要向链中的下一个节点发送update。</p></li><li><p>读操作只涉及tail节点(read ops involve only tail)</p><p>尽管Raft做了read优化，follower就算要处理read请求，还是得向其他leader、followers发送同步log，确定自己是否能够响应read（因为follower可能正好没有最新的数据）。而CR中，只需要tail负责read请求，并且tail一定能同步到最新的write数据（因为write的commit point就是tail节点）。</p></li><li><p>简单的崩溃恢复机制(simple crash recovery)</p><p>与Raft相比，CR的崩溃处理更简单。</p></li></ul><p>CR比起Raft的劣势：</p><ul><li><p>一个节点故障就需要重新配置(one failure requires reconfiguration)</p><p>因为写入操作需要同步到整个链，写入操作无法确认链中每台机器是否都执行，所以一有fail，就需要重新配置，这意味着中间会有一小段时间的停机。而Raft中只需要majority满足write持久化，就可以继续工作。</p></li></ul>',28);function f(_,m){const l=o("ExternalLinkIcon");return n(),s("div",null,[h,i("blockquote",null,[c,i("p",null,[a("分布式服务中要求状态机具有确定性：同一状态机的多个副本以“开始”状态开始，并且以相同顺序接收相同输入将到达已生成相同输出的相同状态。这也就是复制状态机的理解，"),i("a",d,[a("复制状态机"),t(l)]),a("。")])]),g,i("p",null,[i("a",S,[a("Chain Replication：链式复制论文中文翻译"),t(l)])]),u])}const C=r(p,[["render",f],["__file","链式复制.html.vue"]]);export{C as default};
