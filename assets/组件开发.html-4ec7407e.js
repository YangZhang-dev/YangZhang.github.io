import{_ as r,r as c,o as d,c as p,a as n,b as a,d as e,w as t,e as o}from"./app-20538318.js";const l={},u=o('<p>本文介绍了12306项目中的组件库开发。</p><h2 id="基础组件开发" tabindex="-1"><a class="header-anchor" href="#基础组件开发" aria-hidden="true">#</a> 基础组件开发</h2><p>如果说组件为业务代码提供提供了便捷，那么基础组件就是组件库的核心。</p><p>在<code>framwork</code>中创建<code>railway-base-spring-boot-starter</code> 模块</p><h3 id="全局变量" tabindex="-1"><a class="header-anchor" href="#全局变量" aria-hidden="true">#</a> 全局变量</h3><p>创建在所有模块都会用到的全局变量</p><h3 id="全局过滤顺序" tabindex="-1"><a class="header-anchor" href="#全局过滤顺序" aria-hidden="true">#</a> 全局过滤顺序</h3><p>如果在不同的模块中创建过滤器顺序，可能会导致混乱。</p><h3 id="封装spring-ioc" tabindex="-1"><a class="header-anchor" href="#封装spring-ioc" aria-hidden="true">#</a> 封装spring IOC</h3>',9),h=n("h3",{id:"注入属性",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#注入属性","aria-hidden":"true"},"#"),a(" 注入属性")],-1),k={href:"https://blog.csdn.net/qq_39208832/article/details/117233363",target:"_blank",rel:"noopener noreferrer"},b=o(`<p>通过<code>InitializingBean</code>重写<code>afterPropertiesSet</code>，配合自动配置从而设置系统变量，开启安全模式。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FastJsonSafeMode</span> <span class="token keyword">implements</span> <span class="token class-name">InitializingBean</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">&quot;fastjson2.parser.safeMode&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;true&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ApplicationBaseAutoConfiguration</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token annotation punctuation">@ConditionalOnMissingBean</span>
    <span class="token annotation punctuation">@ConditionalOnProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;framework.fastjson.safa-mode&quot;</span><span class="token punctuation">,</span> havingValue <span class="token operator">=</span> <span class="token string">&quot;true&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">FastJsonSafeMode</span> <span class="token function">railwayFastJsonSafeMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FastJsonSafeMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="单例容器" tabindex="-1"><a class="header-anchor" href="#单例容器" aria-hidden="true">#</a> 单例容器</h3><p>引入单例容器，防止一些<strong>无状态</strong>的对象重复创建，消耗系统性能。</p><ul><li>容器采用<code>ConcurrentHashMap</code></li><li>使用<code>@NoArgsConstructor(access = AccessLevel.PRIVATE)</code>生成私有无参构造</li><li>采用函数式接口提供当get的key不存在时，由调用方决定提供对象。</li></ul><h3 id="安全初始化事件" tabindex="-1"><a class="header-anchor" href="#安全初始化事件" aria-hidden="true">#</a> 安全初始化事件</h3>`,6),_=n("strong",null,"发布订阅机制",-1),f=n("strong",null,"准备就绪",-1),m=n("code",null,"ApplicationReadyEvent",-1),v={href:"https://blog.csdn.net/weixin_43378325/article/details/118277450",target:"_blank",rel:"noopener noreferrer"},E=n("blockquote",null,[n("p",null,"一定要记得每个starter最后都要有自动配置文件")],-1),g=n("h2",{id:"规约组件库",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#规约组件库","aria-hidden":"true"},"#"),a(" 规约组件库")],-1),B=n("p",null,"规约组件库相对好理解，在组件库中约定好状态码，异常，响应体，分页。这些需要约定的配置，防止模块之间不协调（如状态码不同一）。",-1),x=n("p",null,"其中对分页的封装可以看作防腐层，由于服务端使用mp，客户端可以不需要导入mp的分页就使用分页类，并且当服务端不再使用mp做分页时，可以做到客户端无感切换。",-1),y=n("h2",{id:"用户组件库",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#用户组件库","aria-hidden":"true"},"#"),a(" 用户组件库")],-1),w=n("p",null,"我们将用户组件库外再套一层业务组件库，为未来可能有的其他业务如订单做准备。",-1),A=n("p",null,[a("很明显这个库的就是为了web领域而写的，所以在自动配置类上可以加入"),n("code",null,"@ConditionalOnWebApplication"),a("。")],-1),C=n("h2",{id:"设计模式组件库",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#设计模式组件库","aria-hidden":"true"},"#"),a(" 设计模式组件库")],-1),j=n("p",null,"在本库中对多种设计模式进行抽象，使得业务场景可以公用，同时也起到了约束的作用。",-1),q=n("h3",{id:"构建者模式",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#构建者模式","aria-hidden":"true"},"#"),a(" 构建者模式")],-1),F=n("h3",{id:"责任链模式",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#责任链模式","aria-hidden":"true"},"#"),a(" 责任链模式")],-1),S=n("code",null,"CommandLineRunner",-1),L=o('<h3 id="策略模式" tabindex="-1"><a class="header-anchor" href="#策略模式" aria-hidden="true">#</a> 策略模式</h3><p>本项目对策略模式做了高度抽象，和责任链相同，使用map来存放多个不同领域的策略，采用base组件库中的安全初始化事件来装配。然后有两种方式选取相应的策略：</p><ul><li>根据mark来指定选择bean</li><li>根据正则表达式模糊匹配mark来选择第一个匹配上的bean</li></ul><h2 id="公用组件库" tabindex="-1"><a class="header-anchor" href="#公用组件库" aria-hidden="true">#</a> 公用组件库</h2><p>提供了公用的一些工具类以及一些公共枚举，最重要的是扩展了快速消费线程池，创建了线程池的构建者模式，使用cglib动态代理扩展了线程池的拒绝策略。<a href="../../code/back/java/juc/%E5%BF%AB%E9%80%9F%E6%B6%88%E8%B4%B9%E7%BA%BF%E7%A8%8B%E6%B1%A0">快速消费线程池</a>。</p><h2 id="分布式id组件库" tabindex="-1"><a class="header-anchor" href="#分布式id组件库" aria-hidden="true">#</a> 分布式id组件库</h2><p>以雪花算法作为基本，结合基因算法，能够更好的分库分表。<a href="../../code/sundry/snowflakeid">雪花算法</a>。</p><h2 id="数据库组件库" tabindex="-1"><a class="header-anchor" href="#数据库组件库" aria-hidden="true">#</a> 数据库组件库</h2><p>引入了自定义的雪花生成器代替mybatis-plus的id生成器，引入了基础的实体类，配置了mp的自动填充，将自定义分页参数和mp的分页参数做了衔接，创建了PageUtil。同时有一个分库分表hash规则，目前没有学习分库分表，后续再补上。</p><h2 id="日志组件库" tabindex="-1"><a class="header-anchor" href="#日志组件库" aria-hidden="true">#</a> 日志组件库</h2><p>通过自定义注解和aop，实现打印日志的功能。</p><h2 id="web组件库" tabindex="-1"><a class="header-anchor" href="#web组件库" aria-hidden="true">#</a> web组件库</h2><p>首先定义了全局返回对象，然后通过aop实现了全局异常处理，包括参数校验异常，应用异常，为捕获异常。</p><p>为了优化servlet的首次响应速度，使用<code>CommandLineRunner</code>在spring初始化时就发送一次请求。</p><h2 id="缓存组件库" tabindex="-1"><a class="header-anchor" href="#缓存组件库" aria-hidden="true">#</a> 缓存组件库</h2><p>在本组件库中，抽象出来了通用的Cache接口，为以后的多级缓存留有扩展空间。定义了分布式缓存接口，实现了Redis缓存组件，采用静态代理对Redis的操作做了增强。其中涉及到了布隆过滤器，以及分布式锁，能够更大限度上的防止缓存击穿和缓存穿透。</p><h2 id="幂等组件库" tabindex="-1"><a class="header-anchor" href="#幂等组件库" aria-hidden="true">#</a> 幂等组件库</h2><p>主要开发了基于parm、token、SpEL的幂等组件，<a href="../../code/sundry/%E5%B9%82%E7%AD%89">幂等处理</a>。</p>',18);function R(T,M){const s=c("RouterLink"),i=c("ExternalLinkIcon");return d(),p("div",null,[u,n("p",null,[a("有时我们需要在非spring管理的类下使用bean，所以我们需要在基础组件库中定义好这个功能，"),e(s,{to:"/code/back/spring/%E9%9D%9Espring%E7%AE%A1%E7%90%86%E7%9A%84%E7%B1%BB%E4%BD%BF%E7%94%A8bean.html"},{default:t(()=>[a("非spring管理的类使用bean")]),_:1}),a("。")]),h,n("p",null,[a("项目中是为了解决fastjson的autotype问题，开启安全模式而设置的属性注入类。"),n("a",k,[a("初探fastJson的AutoType_fastjson autotype作用"),e(i)]),a("。")]),b,n("p",null,[a("在基础库中封装出一个基于"),_,a("的，只在Spring Boot 应用程序"),f,a("时触发的事件，以便于我们执行任务。看上去"),m,a("是一个不错的选择，但是"),n("a",v,[a("springboot启动时多次监听到ApplicationReadyEvent事件"),e(i)]),a("。所以可以通过CAS或锁封装出一个我们自己的，能够保证只在初始化完成后发布一次的事件。"),e(s,{to:"/code/back/spring/springboot%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%9C%BA%E5%88%B6.html"},{default:t(()=>[a("springboot发布订阅机制")]),_:1}),a("。")]),E,g,B,x,n("p",null,[a("在分页中用到了泛型的函数式接口，见下面的文章："),e(s,{to:"/code/back/java/%E6%B3%9B%E5%9E%8B%E5%92%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3.html"},{default:t(()=>[a("泛型和函数式接口")]),_:1}),a("。")]),y,w,n("p",null,[a("在用户组件库中，定义了用户过滤器，如果HTTP Header中有userid这一项，我们就提取出在HTTP Header中的用户各种信息，放置到TTL中："),e(s,{to:"/code/back/java/transmittable-thread-local.html"},{default:t(()=>[a("transmittable-thread-local")]),_:1}),a("。同时封装了jwt的生成和解析操作。")]),A,C,j,q,n("p",null,[e(s,{to:"/code/back/designpattern/builder.html"},{default:t(()=>[a("builder-构建者模式")]),_:1}),a("。")]),F,n("p",null,[e(s,{to:"/code/back/designpattern/chain.html"},{default:t(()=>[a("chain-责任链模式")]),_:1}),a("。在项目中，使用HaspMap存放多个链条，用bean的type做key，标识不同的责任链，将一条链上的组件链接起来，使用Ordered来进行排序。采用"),S,a("在项目初始化完成之前，将责任链装配好。")]),L])}const H=r(l,[["render",R],["__file","组件开发.html.vue"]]);export{H as default};
