import{_ as e,o as n,c as s,e as a}from"./app-20538318.js";const t={},i=a(`<p>本章介绍了汇编语言的基础，讲解了机器级编程的概念</p><h2 id="_1-程序编码" tabindex="-1"><a class="header-anchor" href="#_1-程序编码" aria-hidden="true">#</a> 1. 程序编码</h2><p>编译器基于编程语言的规则，目标机器的指令集和操作系统遵循的惯例，经过一些列的阶段生成机器代码。</p><p>假设有两个c文件<code>p1.c</code> 和<code>p2.c</code>，可以使用下面的命令编译为可执行文件</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>linux<span class="token operator">&gt;</span> gcc <span class="token parameter variable">-Og</span> <span class="token parameter variable">-o</span> p p1.c p2.c
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>gcc是linux默认的c语言编译器，-O是指定优化等级，-Og会生成符合原始c代码整体结构的代码的优化等级，另外还有更高级的优化等级（O1，O2）。</p><p>实际上gcc在编译过程中调用了一整套程序：</p><ol><li>首先，<strong>c预处理器</strong>扩展源代码，插入所有<code>#include</code>指定的文件，扩展所有<code>#define</code>声明的宏，生成两个源文件的<strong>汇编代码</strong>，称作<code>p1.s</code>和<code>p2.s</code>。</li><li>然后<strong>汇编器</strong>会将汇编代码转化成二进制<strong>目标代码</strong>文件，称作<code>p1.o</code>和<code>p2.o</code>，但还没有填入全局值的地址。</li><li>最后，<strong>链接器</strong>将两个目标代码文件和库函数合并，并产生<strong>可执行文件</strong>，称作<code>p</code>。</li></ol><blockquote><p>-o p ：生成可执行文件p</p><p>-S：生成汇编代码</p><p>-c：生成二进制目标代码</p></blockquote><p>在linux中可以使用下面的命令对一个可执行文件进行反编译，生成汇编代码。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>linux<span class="token operator">&gt;</span> objdump <span class="token parameter variable">-d</span> p
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_1-1-机器级代码" tabindex="-1"><a class="header-anchor" href="#_1-1-机器级代码" aria-hidden="true">#</a> 1.1 机器级代码</h3><p>对于机器级编程，有两种抽象很重要：</p><ol><li><strong>指令集架构</strong>（ISA）来定义机器级程序的格式和行为，它定义了处理器状态，指令的格式，以及每条指令对状态的影响。</li><li>机器级程序使用的内存是<strong>虚拟内存</strong>，提供的内存模型像是一个很大的字节数组</li></ol><p>机器级代码中有很多处理器的状态都是可见的：</p><ol><li>程序计数器（PC，在x86-64中以%rip表示），给出下一条指令在内存中的地址。</li><li>整数寄存器文件，包含16个64位的寄存器，有的用来记录某些重要的运行状态，有的用来保存临时数据（局部变量，返回值）。</li><li>条件码寄存器，保存着最近计算的状态信息，用来实现控制，或数据流的条件变化（if，while，for，switch）。</li><li>一组向量寄存器，用来存放多个正数或浮点数的值。</li></ol><p>注意：程序的内存包括：程序的可执行的机器代码，操作系统需要的信息，用来管理过程调用和返回的栈，用户分配的内存块（malloc）。</p><h3 id="_1-2-数据格式" tabindex="-1"><a class="header-anchor" href="#_1-2-数据格式" aria-hidden="true">#</a> 1.2 数据格式</h3><p>在x86-64中有以下术语：</p><table><thead><tr><th style="text-align:center;">C声明</th><th style="text-align:center;">Intel数据类型</th><th style="text-align:center;">汇编代码后缀</th><th style="text-align:center;">大小（字节）</th></tr></thead><tbody><tr><td style="text-align:center;">char</td><td style="text-align:center;">字节</td><td style="text-align:center;">b</td><td style="text-align:center;">1</td></tr><tr><td style="text-align:center;">short</td><td style="text-align:center;">字</td><td style="text-align:center;">w</td><td style="text-align:center;">2</td></tr><tr><td style="text-align:center;">int</td><td style="text-align:center;">双字</td><td style="text-align:center;">l</td><td style="text-align:center;">4</td></tr><tr><td style="text-align:center;">long</td><td style="text-align:center;">四字</td><td style="text-align:center;">q</td><td style="text-align:center;">8</td></tr><tr><td style="text-align:center;">char*</td><td style="text-align:center;">四字</td><td style="text-align:center;">q</td><td style="text-align:center;">8</td></tr><tr><td style="text-align:center;">float</td><td style="text-align:center;">单精度</td><td style="text-align:center;">s</td><td style="text-align:center;">4</td></tr><tr><td style="text-align:center;">double</td><td style="text-align:center;">双精度</td><td style="text-align:center;">l</td><td style="text-align:center;">8</td></tr></tbody></table><p>由于浮点数使用的是一组完全不同的指令和寄存器，所以两个<code>l</code>不会有歧义。</p><h2 id="_2-访问信息" tabindex="-1"><a class="header-anchor" href="#_2-访问信息" aria-hidden="true">#</a> 2. 访问信息</h2><p>一个x86-64的cpu中包含一组16个64位的通用目的寄存器</p><img src="http://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/6e719e1eb91dc46ef1d8bded9bb61f8a.jpg" style="zoom:25%;"><p>可以通过不同的指令访问到低4字节，低2字节，和最低的字节。当这些寄存器作为目标时，对于小于8个字节的命令，高位的字节会怎么改变呢？有两条规则：</p><ol><li>生成1字节和2字节数字的指令会保证剩下的字节不变。</li><li>生成4字节的指令会把高位的4个字节值为零。</li></ol><h3 id="_2-1-操作数指示符" tabindex="-1"><a class="header-anchor" href="#_2-1-操作数指示符" aria-hidden="true">#</a> 2.1 操作数指示符</h3><p>大多数指令有一个或多个操作数，指示一个操作要使用的源数据以及放置结果的目的位置。</p><p>源数据可以以立即数（常数）给出，或从寄存器、内存中读出。结果可以存放在寄存器或内存中。</p><p>因此操作数可以分为三种类型，第一种是立即数，通常在前面加上<code>$</code>。第二种是寄存器，它表示寄存器中的值（任意指定低位1，2，4，8个字节）。第三种是内存引用，它表示内存中的值。以下的图更加清晰易懂。 <img src="http://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/b05d6a654bb315c4d5d8aab3cc779ae5.jpg" style="zoom:25%;"></p><h3 id="_2-2-数据传输指令" tabindex="-1"><a class="header-anchor" href="#_2-2-数据传输指令" aria-hidden="true">#</a> 2.2 数据传输指令</h3><p>最频繁使用的指令就是数据传输指令，mov指令把数据从源位置复制到目标位置，不做任何变化</p><p>根据操作数不同，有以下五种，其中内存复制到内存被认为是不安全的操作，不被允许 <img src="http://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/6de7c28c3ab5a8f27c0d8b3ca2c0731a.png" style="zoom:50%;"></p><p>同时，根据数据类型的不同，可以分为</p><table><thead><tr><th style="text-align:center;">MOV S，D</th><th style="text-align:center;">D&lt;-S</th><th style="text-align:center;">传送</th></tr></thead><tbody><tr><td style="text-align:center;">movb</td><td style="text-align:center;"></td><td style="text-align:center;">传送字节</td></tr><tr><td style="text-align:center;">movw</td><td style="text-align:center;"></td><td style="text-align:center;">传送字</td></tr><tr><td style="text-align:center;">movl</td><td style="text-align:center;"></td><td style="text-align:center;">传送二字</td></tr><tr><td style="text-align:center;">movq</td><td style="text-align:center;"></td><td style="text-align:center;">传送四字</td></tr></tbody></table><p>对于从小到大的传输，又有两种分类:<code>movz</code>和<code>movs</code>，举例说明：</p><p><code>movzbq</code>将做了零扩展的字节传输到四字，等等。<code>movsbq</code>将做了符号扩展的字节传输到四字，等等。具体见P123</p><h3 id="_2-3-压入或弹出栈数据" tabindex="-1"><a class="header-anchor" href="#_2-3-压入或弹出栈数据" aria-hidden="true">#</a> 2.3 压入或弹出栈数据</h3><p>在x86-64中，栈存放在内存中的一个区域，栈是向下增长的，也就是地址不断减小，发生增加或删除的一端称为栈顶，有一个寄存器专门用来保存栈顶指针，称作<code>%rsp</code>。对于压栈入栈操作，有：pushq和popq。</p><p>pushq 将寄存器的值或立即数压入栈中，popq 将栈中的值存入寄存器中（由于内存到内存的操作时禁止的，所以不能直接写入内存中）</p><p>将一个四字压入栈中有两步：</p><ol><li>将栈指针减去8</li><li>将值写入新的栈指针</li></ol><p>注意，pop之后元素不会消失，而是等待下一次被覆盖。</p><h2 id="_3-算术和逻辑操作" tabindex="-1"><a class="header-anchor" href="#_3-算术和逻辑操作" aria-hidden="true">#</a> 3. 算术和逻辑操作</h2><p>分为四组：加载有效地址，一元操作，二元操作，移位，具体见下图： <img src="http://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/2e1ca750fa65ec5a9c3c53a0beb28396.jpg" style="zoom:25%;"></p><ul><li><p>加载有效地址</p><p>它和<code>mov</code>很相似，不过它不会去内存中加载数据，而是直接将计算结果存入目的地中，举例解释：设<code>%rdx</code>的值是x，则<code>leaq 7(%rdx,%rdx,4),%rax</code>就是将%rax的值设置为5x+7。当用于将有效地址写入目的数时，源操作数中存的就是地址，例如在c语言中使用<code>&amp;S</code>取地址时会用到，详见过程调用中的栈上的局部存储</p></li><li><p>一元操作和二元操作</p></li></ul><p>​ 包括一些加减乘，位操作等</p><ul><li>移位操作</li></ul><p>​ 分为逻辑和算数移位</p><h2 id="_4-控制" tabindex="-1"><a class="header-anchor" href="#_4-控制" aria-hidden="true">#</a> 4. 控制</h2><p>测试数据，然后根据测试的结果来改变控制流和数据流，这是机器代码实现有条件的行为。通过计算测试，将计算结果的一些特征（进位，零，符号，溢出）放入条件码寄存器，接着访问条件码，根据条件码，使用不同的jump指令实现条件判断。</p><h3 id="_4-1-条件码" tabindex="-1"><a class="header-anchor" href="#_4-1-条件码" aria-hidden="true">#</a> 4.1 条件码</h3><p>在cpu中有一组单个位的条件码寄存器，它保留最近计算和逻辑操作的属性，包括</p><ul><li>CF：进位标志。最近的操作使最高位产生了进位，可以用来检查无符号操作的溢出。</li><li>ZF：零标志。最近的操作得出结果位0。</li><li>SF：符号标志。最近操作得到的结果为负数。</li><li>OF：溢出标志。最近的操作导致补码正溢出或负溢出</li></ul><p>除了算数和逻辑操作符可以设置条件码，还有两个指令cmp和test也可以设置</p><ul><li>cmp的行为和sub相同，但不会改变寄存器的值</li><li>test和add行为相同，但不会改变寄存器的值</li></ul><h3 id="_4-2-访问条件码" tabindex="-1"><a class="header-anchor" href="#_4-2-访问条件码" aria-hidden="true">#</a> 4.2 访问条件码</h3><p>使用条件码的三种形式：</p><ol><li>根据条件码多不同组合，将一个字节设置为0，1</li><li>根据条件码，程序可以条件的跳转到程序的某个其他部分</li><li>有条件的传送数据</li></ol><p>这里讨论第一种情况，通常使用set指令，set的指令表如下： <img src="http://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/0c1e441030c9383e343caf2623ddabc2.jpg" style="zoom:25%;"></p><h3 id="_4-3-跳转指令" tabindex="-1"><a class="header-anchor" href="#_4-3-跳转指令" aria-hidden="true">#</a> 4.3 跳转指令</h3><p>跳转指令可以使程序切换到一个全新的位置，这些跳转的目的地通常使用<strong>标签</strong>（label）来指明，下面是一段伪代码：</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>	movq $0,%rax
	jmp .L1
	movq (%rax),%rdx
  .L1:
	popq %rdx
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>.L1</code>是跳转的标签，程序会跳过jmp下面的一条指令，跳转到指定地址。</p><p>jmp跳转是无条件跳转：分为<strong>直接跳转</strong>和<strong>间接跳转</strong>，直接跳转即跳转目标是作为指令的一部分编码的，间接跳转级跳转目标是从寄存器或内存位置中读出来的。</p><p>下图是jump指令表： <img src="http://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/b41e85b798c1632b92d367e52ca903d5.jpg" style="zoom:25%;"></p><p>前面两个是无条件跳转，在c语言中类似<code>goto</code>，后面的是配合条件码实现有条件跳转，也就是条件码的第二种使用方式，下面举个例子：</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>	cmpq %rsi,%rdi
	jge .L1
	inc %rdx
  .L1:
	popq %rdx
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>cmpq判断的结果存放在条件码中，jge通过条件码的组合，判断是否是大于等于，如果满足条件，就跳转。这就是基于<strong>条件控制</strong>来实现条件分支。</p><p>实现条件分支，还有一种方法，叫做<strong>条件传送</strong>，也就是条件码的第三种使用方式，大致意思是程序会将每一个分支中的程序都计算一边，将结果存放到不同的地方，最后根据条件进行数据传送（函数返回，数据复制等等），这样的性能会更好。</p><p>下图是条件传送指令表 <img src="http://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/3d27da65ab5f1e8745de1137f5d85c40.jpg" style="zoom:25%;"></p><p>为什么性能会好呢？因为cpu有一种叫做<strong>流水线</strong>（pipelining）的工艺，一条指令会分成很多步，比如从内存中取出指令，确定指令类型，读数据，运算，写数据，更新PC等，在内存中取一条指令时，它会执行前一条指令的运算操作，要实现这个功能，就必须对条件分支进行预测，如果预测对了还好，预测错了它就会丢掉所有做错的指令，会导致性能严重下降。</p><p>但是使用条件传送有时会导致错误，如：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">long</span> <span class="token function">cread</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>p <span class="token operator">?</span> <span class="token operator">*</span>p <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>created:
	moveq (%rdi), %rax
	testq %rdi, %rdi
	movel $0, %edx
	cmove %rdx, %rax
	ret
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码本来是预防了空指针错误，但是由于编译器会都执行一边，导致出错。</p><p>条件传送也不一定会提高效率。如果在分支中存在大量的计算也会增加很多运行时间。</p><p>编译器会在安全性和性能方面都均衡考虑，选择最佳的编译方式。</p><h3 id="_4-4-循环和switch" tabindex="-1"><a class="header-anchor" href="#_4-4-循环和switch" aria-hidden="true">#</a> 4.4 循环和switch</h3><p>在c语言中分为三种循环do-while、while、for，可以先学习do-while，然后进一步扩展到while和for。</p><h4 id="_4-4-1-do-while" tabindex="-1"><a class="header-anchor" href="#_4-4-1-do-while" aria-hidden="true">#</a> 4.4.1 do-while</h4><p>do-while的c语言通用格式如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">do</span>
    body<span class="token operator">-</span>statement
    <span class="token keyword">while</span><span class="token punctuation">(</span>test<span class="token operator">-</span>expr<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种通用形式可以翻译为如下的条件测试和<code>goto</code>语句：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>loop<span class="token operator">:</span>
	body<span class="token operator">-</span>statement
    t <span class="token operator">=</span> test<span class="token operator">-</span>expr<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span>
      <span class="token keyword">goto</span> loop<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中逻辑已经可以使用汇编中的条件码和跳转指令来实现了。</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>  .L2:
	...
	cmpq ...
	jg .L2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>jg可以换为其他的跳转指令。</p><h4 id="_4-4-2-while" tabindex="-1"><a class="header-anchor" href="#_4-4-2-while" aria-hidden="true">#</a> 4.4.2 while</h4><p>while的通用语句如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">while</span><span class="token punctuation">(</span>test<span class="token operator">-</span>expr<span class="token punctuation">)</span>
    body<span class="token operator">-</span>statement
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>实现其的汇编代码有两种方式：<code>jump to middle</code>和<code>guarded-do</code>。</p><p>第一种策略是使用了do-while的模板，然后在最开始使用无条件跳转到测试处。下面是使用goto的实现：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>	<span class="token keyword">goto</span> test<span class="token punctuation">;</span>
loop<span class="token operator">:</span>
	body<span class="token operator">-</span>statement
test<span class="token operator">:</span>
	t <span class="token operator">=</span> test<span class="token operator">-</span>expr
	<span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span>
      <span class="token keyword">goto</span> loop<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第二种策略也是使用do-while的模板，不同的是，会在最开始条件测试，它和循环种的测试是相同的，下面是<code>goto</code>的实现：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>t <span class="token operator">=</span> test<span class="token operator">-</span>expr<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>t<span class="token punctuation">)</span>
    <span class="token keyword">goto</span> done<span class="token punctuation">;</span>
loop<span class="token operator">:</span>
	body<span class="token operator">-</span>statement
	t <span class="token operator">=</span> test<span class="token operator">-</span>expr<span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>
      <span class="token keyword">goto</span> test<span class="token punctuation">;</span>
done<span class="token operator">:</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第二种通常是在开启了较高的优化等级之后才会采用的策略。</p><h4 id="_4-4-3-for" tabindex="-1"><a class="header-anchor" href="#_4-4-3-for" aria-hidden="true">#</a> 4.4.3 for</h4><p>for循环的通用语句如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">for</span> <span class="token punctuation">(</span>init<span class="token operator">-</span>expr<span class="token punctuation">;</span> test<span class="token operator">-</span>expr<span class="token punctuation">;</span> update<span class="token operator">-</span>expr<span class="token punctuation">)</span>
    body<span class="token operator">-</span>statement
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>等同于：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>init<span class="token operator">-</span>expr<span class="token operator">:</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>test<span class="token operator">-</span>expr<span class="token punctuation">)</span><span class="token punctuation">{</span>
    body<span class="token operator">-</span>statement
    update<span class="token operator">-</span>expr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译器会根据优化等级来选择while模板</p><h4 id="_4-4-5-switch" tabindex="-1"><a class="header-anchor" href="#_4-4-5-switch" aria-hidden="true">#</a> 4.4.5 switch</h4><p>switch根据一个整数索引进行多重分支，在底层的实现是使用了一个叫做<strong>跳转表</strong>的数据结构。跳转表是一个数组，每个元素是一个代码段的地址。下面是一个伪代码：</p><p>注意104后没有加<code>break</code>，这会导致接着执行106的语句。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">switch_eg</span><span class="token punctuation">(</span><span class="token keyword">long</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">switch</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token number">101</span><span class="token operator">:</span>
            statement
            <span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token keyword">case</span> <span class="token number">104</span><span class="token operator">:</span>
            statement
		<span class="token keyword">case</span> <span class="token number">106</span><span class="token operator">:</span>
            statement
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
            statement
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译出来的汇编（伪代码）</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>switch_eg:
	subq	$101, %rdi
	cmpq	$6, %rdi
	ja   	.L2
	jmp  	*.L4(,%rdi,8)	; 间接寻址
  .L3:
	...
	jmp .L2
  .L5:
	...
	jmp .L2
  .L2:
	...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>跳转表（伪代码）</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>	.section	.rodata		; 只读数据
	.aligen 8	;	
.L4:
	.quad	.L3
	.quad	.L6
	.quad	.L6
	.quad	.L6
	.quad	.L5
	.quad	.L6
	.quad	.L5
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先编译器会将n减去101，并且将n的取值映射正整数到<code>0~5</code>，创建一个新的变量。注意比较使用的是无符号<code>ja</code>指令，如果n是补码负数，则会转化变为非常大的无符号数，这样就可以只判断是否大于5。然后根据跳转表跳转到指定的代码块进行执行。</p><p>当case的数量很少（4个）时，编译器会编译为<code>if-else</code>结构，当范围大且稀疏时，使用<code>if-else</code>加上二分的方式.。</p>`,113),l=[i];function d(c,p){return n(),s("div",null,l)}const r=e(t,[["render",d],["__file","csapp-程序的机器级表示(1).html.vue"]]);export{r as default};
