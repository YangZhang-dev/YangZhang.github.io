import{_ as p,r as t,o as c,c as i,a as n,b as s,d as e,e as o}from"./app-20538318.js";const l={},r={href:"https://zhuanlan.zhihu.com/p/351550104",target:"_blank",rel:"noopener noreferrer"},u={href:"https://zhuanlan.zhihu.com/p/135462276",target:"_blank",rel:"noopener noreferrer"},d={href:"https://xiaolincoding.com/os/1_hardware/cpu_mesi.html",target:"_blank",rel:"noopener noreferrer"},k={href:"https://zhuanlan.zhihu.com/p/125737864",target:"_blank",rel:"noopener noreferrer"},b={href:"https://www.scss.tcd.ie/Jeremy.Jones/VivioJS/caches/MESIHelp.htm",target:"_blank",rel:"noopener noreferrer"},h=o(`<h2 id="cpu-cache" tabindex="-1"><a class="header-anchor" href="#cpu-cache" aria-hidden="true">#</a> CPU Cache</h2><p>首先引出现代CPU的架构：</p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/4e7fb24d005f3ccba53e1cf89dde2207.png" alt="image-20231204175301087" style="zoom:67%;"><p>L1和L2都是片内缓存，只可由响应的CPU单独使用，而L3是由所有CPU所共享的。其中L1l是指令缓存，而L1D是数据缓存。缓存和主存都是RAM，只不过缓存时SRAM而主存时DRAM。</p><p>缓存的基本单位是<strong>缓存行</strong>，缓存行中包含一些头信息和具体的数据，头信息有很多，包括脏位等等。从主存中拿出一次就是拿出一行数据，可以通过下面的方式获取以字节为单位的缓存行的大小：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># L1D Cache</span>
getconf LEVEL1_DCACHE_LINESIZE

<span class="token comment"># L1I Cache</span>
getconf LEVEL1_ICACHE_LINESIZE

<span class="token comment"># L2 Cache</span>
getconf LEVEL2_CACHE_LINESIZE

<span class="token comment"># L3 Cache</span>
getconf LEVEL3_CACHE_LINESIZE
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="写缓存策略" tabindex="-1"><a class="header-anchor" href="#写缓存策略" aria-hidden="true">#</a> 写缓存策略</h2><p>这里涉及到计组的知识，写缓存包含两个策略：</p><ul><li>写直达：每次写缓存后都直接写入内存中，保证数据一致性，但是xiaolv低下，每次写入不仅要访问缓存，而且要访问内存。</li><li>写回：写入缓存后，将脏位设置为1，不需要写入内存，当缓存块需要被替换下时，将缓存写回主存。</li></ul><h2 id="缓存不一致" tabindex="-1"><a class="header-anchor" href="#缓存不一致" aria-hidden="true">#</a> 缓存不一致</h2><p>由于写直达性能低下，一般采用写回法。但是这样就会引入CPU缓存不一致问题，设想当CPU1对数据x写入1，由于采用写回法，所以内存中的x依然为0。这时CPU2从内存中把x载入缓存中，读取的x就为0，现在就发生了缓存不一致的情况。</p><p>对于这种情况，我们要保证两点：首先要让CPU之间能够<strong>通信</strong>，也就是当CPU1修改x时，其他的CPU可以收到这个信息。一切的有序都要以沟通为基础，互相什么都不知道就无法保证有序和同步。</p><p>其次，我们需要将不同的CPU上的修改事件像数据库中的<strong>串行化</strong>一样执行，不然可能会出现以下情况：</p><p>首先CPU1将x改为1，通知其他的CPU。同时CPU2将x改为2，通知其他CPU。当CPU1发送通知时，占用总线，CPU2收到后将x改为1。当CPU1发送完毕后，CPU2发送通知，CPU1将x改为1，数据不一致的情况发生了。</p><h2 id="总线嗅探" tabindex="-1"><a class="header-anchor" href="#总线嗅探" aria-hidden="true">#</a> 总线嗅探</h2><p>CPU感知其他CPU的行为（比如读、写某个缓存行）就是是通过嗅探（Snoop）线性中其他CPU发出的请求消息完成的，有时CPU也需要针对总线中的某些请求消息进行响应。这被称为”总线嗅探机制“。</p><p>总线嗅探上的六种消息如下：</p><ul><li><p>Read: 读取某个地址的数据。目的地是其他的CPU和内存，包含待读取的数据地址。</p></li><li><p>Read Response: Read 消息的响应。包含数据内容，可能是内存返回的，也可能是其他CPU返回的。</p></li><li><p>Invalidate: 请求其他 CPU invalid 地址对应的缓存行。</p></li><li><p>Invalidate Acknowledge: Invalidate 消息的响应。</p></li><li><p>Read Invalidate: Read + Invalidate 消息的组合消息。</p></li><li><p>Writeback: 该消息包含要回写到内存的地址和数据。</p></li></ul><h2 id="mesi" tabindex="-1"><a class="header-anchor" href="#mesi" aria-hidden="true">#</a> MESI</h2><p>接下来就要设计一种协议来保证修改的串行化，MESI协议是：</p><ul><li><em>Modified</em>，已修改</li><li><em>Exclusive</em>，独占</li><li><em>Shared</em>，共享</li><li><em>Invalidated</em>，已失效</li></ul><p>的缩写，代表缓存行的状态，存在于缓存行的Tag。</p><p>如果缓存行的状态是S或者E，代表可以当前缓存和主存中数据是一致的。</p><p>如果缓存行中的状态是E或者M，代表当前的读写操作可以直接对缓存进行。</p><p>由此可以看出，对于一个CPU来说，一个缓存行可能存在四种事件：本地读，本地写，远程读，远程写。</p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/dd4889cca58dad06db724c704553087f.png" alt="image-20231204200308215" style="zoom:67%;"><p>上面的图是缓存行的状态机表示图，下面的是整个流程的状态和数据的变化：</p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/115d9472dd83822d99850a4ecce6b6ca.webp" alt="_MESI状态转换表格" style="zoom:67%;"><h3 id="store-buffer" tabindex="-1"><a class="header-anchor" href="#store-buffer" aria-hidden="true">#</a> Store buffer</h3><p>Store buffer是CPU和cache之间的一个缓冲区，CPU不会等待其他的CPU将信息发送过来才将缓存行改变，而是将要改变的值放入Store buffer中，等待其他CPU响应后，CPU才把数据写入缓存行中。所以CPU会先查Store buffer，再查cache（Store Forwarding）。</p><h3 id="invalided-queue" tabindex="-1"><a class="header-anchor" href="#invalided-queue" aria-hidden="true">#</a> Invalided Queue</h3><p>接收方的CPU存在一个队列，当收到其他CPU相关的Invalided消息后，将对应的缓存行放入队列中，然后就可以直接返回了。</p><p>一旦将一个invalidate（例如针对变量a的cacheline）消息放入CPU的Invalidate Queue，实际上该CPU就等于作出这样的承诺：在处理完该invalidate消息之前，不会发送任何相关（即针对变量a的cacheline）的MESI协议消息。</p><h3 id="总线风暴" tabindex="-1"><a class="header-anchor" href="#总线风暴" aria-hidden="true">#</a> 总线风暴</h3><p>我们知道，多核处理器都是公用的同一个总线，如果一个CPU占用了总线，那么其他的CPU就不能够使用总线。对于多个线程操作同一个变量来说，我们可能会用到CAS机制，其中可能涉及到CPU的盲轮询，倒是总线上的缓存一致性流量激增，降低CPU的效率。</p><h2 id="内存屏障" tabindex="-1"><a class="header-anchor" href="#内存屏障" aria-hidden="true">#</a> 内存屏障</h2><h3 id="写内存屏障" tabindex="-1"><a class="header-anchor" href="#写内存屏障" aria-hidden="true">#</a> 写内存屏障</h3><p>在引入了Store buffer后，可能会出现下面的问题：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">fun0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   
  a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   
  b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
  <span class="token keyword">while</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>  
  <span class="token function">assert</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>CPU0执行fun0，拥有b的缓存，CPU1执行fun1，拥有a的缓存。</p><ol><li>CPU 0执行a=1的赋值操作，由于a不在local cache中，因此，CPU 0将<strong>a值放到store buffer中</strong>之后，发送了read invalidate命令到总线上去。</li><li>CPU 1执行 while (b == 0) 循环，由于b不在CPU 1的cache中，因此，CPU发送一个read message到总线上，看看是否可以从其他cpu的local cache中或者memory中获取数据。</li><li>CPU 0继续执行b=1的赋值语句，由于b就在自己的local cache中（cacheline处于modified状态或者exclusive状态），因此CPU0可以<strong>直接操作将b新的值1写入cache line</strong>。</li><li>CPU 0收到了read message，将最新的b值”1“回送给CPU 1，同时将b cacheline的状态设定为shared。</li><li>CPU 1收到了来自CPU 0的read response消息，将b变量的最新值”1“值写入自己的cacheline，状态修改为shared。</li><li>由于b值等于1了，因此CPU 1跳出while (b == 0)的循环，继续执行。</li><li>CPU 1执行assert(a == 1)，这时候CPU 1的local cache中还是旧的a值，因此assert(a == 1)失败。</li><li>CPU 1收到了来自CPU 0的read invalidate消息，以a变量的值进行回应，同时清空自己的cacheline。</li><li>CPU 0收到了read response和invalidate ack的消息之后，将store buffer中的a的最新值”1“数据写入cacheline。</li></ol><p>总结来说就是CPU0对a的写操作还在Store buffer，对b的写却直接写入cache line，导致CPU1只拿到了b的最新值，而a的值还是cache line中的旧值。</p><p>所以在这里要引入写内存屏障（<strong>Store Memory Barrier</strong>）</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">fun0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   
  a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   
  <span class="token function">smp_mb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
  b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   
  <span class="token keyword">while</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
  <span class="token function">assert</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>写内存屏障保证了数据在本地cache中的操作顺序是和程序相同的，在上文中就是必须要a=1写入cache line完毕后，才能执行b=1写入cache line。</p><p>一种做法是，直接<strong>清空Store buffer</strong>，CPU等待所有Store buffer中的数据写入cache line后再执行下一条指令。</p><p>另一种做法是记录Store buffer中的顺序，并且对需要等待表项marked，并且当Store buffer中含有数据时，即使下一条指令的数据存在cache line中，也需要加入Store buffer，只不过不需要marked。</p><h3 id="读内存屏障" tabindex="-1"><a class="header-anchor" href="#读内存屏障" aria-hidden="true">#</a> 读内存屏障</h3><p>上面的做法仍然有问题：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>a <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">fun0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    
  a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    
  <span class="token function">smp_mb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
  b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>	
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    
   <span class="token keyword">while</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
   <span class="token function">assert</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假设 a 存在于 CPU 0 和 CPU 1 的 local cache 中，b 存在于 CPU 0 中。CPU 0 执行 fun1() , CPU 1 执行 fun2() 。操作序列如下：</p><ol><li><p>CPU 0执行a=1的赋值操作，由于a在CPU 0 local cache中的cacheline处于shared状态，因此，CPU 0将a的新值“1”放入store buffer，并且发送了invalidate消息去清空CPU 1对应的cacheline。</p></li><li><p>CPU 1执行while (b == 0)的循环操作，但是b没有在local cache，因此发送read消息试图获取该值。</p></li><li><p>CPU 1收到了CPU 0的invalidate消息，<strong>放入Invalidate Queue，并立刻回送Ack</strong>。</p></li><li><p>CPU 0收到了CPU 1的invalidate ACK之后，即可以越过程序设定内存屏障（第四行代码的smp_mb() ），这样a的新值从store buffer进入cacheline，状态变成Modified。</p></li><li><p>CPU 0 越过memory barrier后继续执行b=1的赋值操作，由于b值在CPU 0的local cache中，因此store操作完成并进入cache line。</p></li><li><p>CPU 0收到了read消息后将b的最新值“1”回送给CPU 1，并修正该cacheline为shared状态。</p></li><li><p>CPU 1收到read response，将b的最新值“1”加载到local cacheline。</p></li><li><p>对于CPU 1而言，b已经等于1了，因此跳出while (b == 0)的循环，继续执行后续代码。</p></li><li><p>CPU 1执行assert(a == 1)，但是由于这时候CPU 1 cache的a值仍然是<strong>旧值0</strong>，因此assert 失败。</p></li><li><p>Invalidate Queue中针对a cacheline的invalidate消息<strong>最终会被CPU 1执行，将a设定为无效</strong>。</p></li></ol><p>总结来说就是当引入Invalided Queue后，我们的Invalided Queue中的失效信息不是实时和Cache line匹配的，当我们将失效信息放入队列中时，我们仍然读的是cache line中的旧数据。</p><p>所以需要引入读内存屏障（<strong>Load Memory Barrier</strong>）</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>a <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">fun0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    
  a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    
  <span class="token function">smp_mb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
  b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    
  <span class="token keyword">while</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>    
  <span class="token function">smp_rmb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">assert</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当CPU执行memory barrier指令的时候，对当前Invalidate Queue中的所有的entry进行标注，这些被标注的项被称为marked entries，而随后CPU执行的任何的load操作都需要等到Invalidate Queue中所有marked entries完成对cacheline的操作之后才能进行。也就是所有的读操作，都需要queue清空，将失效信息放置到cache line后才可以进行。</p>`,56);function v(m,C){const a=t("ExternalLinkIcon");return c(),i("div",null,[n("p",null,[n("a",r,[s("并发吹剑录（一）：CPU缓存一致性协议MESI - 知乎 (zhihu.com)"),e(a)])]),n("p",null,[n("a",u,[s("CPU中的缓存、缓存一致性、伪共享和缓存行填充 - 知乎 (zhihu.com)"),e(a)])]),n("p",null,[n("a",d,[s("2.4 CPU 缓存一致性 | 小林coding (xiaolincoding.com)"),e(a)])]),n("p",null,[n("a",k,[s("内存屏障（Memory Barrier）究竟是个什么鬼？ - 知乎 (zhihu.com)"),e(a)])]),n("p",null,[n("a",b,[s("VivioJS MESI help (tcd.ie)"),e(a)])]),h])}const P=p(l,[["render",v],["__file","CPU缓存一致性.html.vue"]]);export{P as default};
