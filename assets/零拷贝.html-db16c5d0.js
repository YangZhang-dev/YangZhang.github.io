import{_ as t,r as c,o as p,c as l,a as n,b as s,d as e,e as o}from"./app-20538318.js";const i={},d=o(`<p>传统IO模型，上下文切换（陷入内核），内存拷贝</p><p>DMA</p><p>mmap</p><p>sendfile</p><p>在介绍零拷贝之前，需要先了解传统的<strong>阻塞I/O模型</strong>。</p><h2 id="dma" tabindex="-1"><a class="header-anchor" href="#dma" aria-hidden="true">#</a> DMA</h2><p>在没有DMA之前，在阻塞I/O的模式下，从磁盘读取到网卡发送：</p><div class="language-pseudocode line-numbers-mode" data-ext="pseudocode"><pre class="language-pseudocode"><code>while((n = read(diskfd, buf, BUF_SIZE)) &gt; 0)
    write(sockfd, buf , n);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>工作流程如下： <img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/d67e6abf55878505ff02cc2dba207658.png" alt="" loading="lazy"></p><p>可以发现，在从磁盘读取的过程中，涉及到了<strong>两次CPU拷贝，两次上下文切换</strong>。在从向socket写数据的过程中，也涉及到了<strong>两次CPU拷贝，两次上下文切换</strong>，一共涉及到了<strong>四次CPU拷贝，四次上下文切换</strong>。</p><p><strong>拷贝数据</strong>这种任务，属于又脏又耗时间的活，如果都让CPU干了，别的线程就要急死了，所以我们要想办法减少甚至不让CPU参与进来！</p><p>所以就引入了直接内存访问（Direct Memory Access，<strong>DMA</strong>），它就像CPU的小弟一样，指哪打哪。用来代替CPU完成数据拷贝这种任务。</p><blockquote><p>DMA传输将数据从一个地址空间复制到另一个地址空间，提供在外设和存储器之间或者存储器和存储器之间的高速数据传输。当CPU初始化这个传输动作，传输动作本身是由DMA控制器来实现和完成的。DMA传输方式无需CPU直接控制传输，也没有中断处理方式那样保留现场和恢复现场过程，通过硬件为RAM和IO设备开辟一条直接传输数据的通道，使得CPU的效率大大提高。</p></blockquote><p>在加入DMA后，工作流程有了一些改变：</p><p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/6d6c4dd54e560fa5456acebe09a256f5.png" alt="" loading="lazy"></p><p>可以看出，现在一共涉及到了<strong>两次CPU拷贝，四次上下文切换</strong>。</p><h2 id="零拷贝" tabindex="-1"><a class="header-anchor" href="#零拷贝" aria-hidden="true">#</a> 零拷贝</h2>`,17),r={href:"https://zhuanlan.zhihu.com/p/362499466",target:"_blank",rel:"noopener noreferrer"},u={href:"https://zhuanlan.zhihu.com/p/447890038",target:"_blank",rel:"noopener noreferrer"},g=n("p",null,"我们可以看到，如果应用程序不对数据做修改，从内核缓冲区到用户缓冲区，再从用户缓冲区到内核缓冲区。两次数据拷贝都需要CPU的参与，并且涉及用户态与内核态的多次切换，加重了CPU负担。所以引入了零拷贝技术。",-1),m=n("p",null,"零拷贝字面上的意思包括两个，零和拷贝：",-1),h=n("ul",null,[n("li",null,"拷贝：就是指数据从一个存储区域转移到另一个存储区域。"),n("li",null,"零：表示次数为0，它表示拷贝数据的次数为0。")],-1),f=n("h3",{id:"mmap",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#mmap","aria-hidden":"true"},"#"),s(" mmap")],-1),k={href:"https://zhuanlan.zhihu.com/p/546009181",target:"_blank",rel:"noopener noreferrer"},_={href:"https://zhuanlan.zhihu.com/p/366964820",target:"_blank",rel:"noopener noreferrer"},b=o(`<p>mmap的函数原型如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mmap</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> length<span class="token punctuation">,</span> <span class="token keyword">int</span> prot<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token class-name">off_t</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>mmap是Linux提供的一种<strong>内存映射文件</strong>的机制，它实现了将<strong>内核空间缓冲区</strong>（Page Cache）与<strong>用户空间缓冲区</strong>地址进行映射，从而实现内核缓冲区与用户缓冲区的共享。我们知道，对文件进行读写时需要经过页缓存进行中转的。所以当虚拟内存地址映射到文件的页缓存后，就可以直接通过读写映射区内存来对文件进行读写操作。</p><blockquote><p>下面介绍一下 <code>mmap</code> 函数的各个参数作用：</p><ul><li><p><code>addr</code>：指定映射的虚拟内存地址，可以设置为 NULL，让 Linux 内核自动选择合适的虚拟内存地址。</p></li><li><p><code>length</code>：映射的长度。</p></li><li><p><code>prot</code>：映射内存的保护模式，可选值如下：</p></li><li><ul><li><code>PROT_EXEC</code>：可以被执行。</li><li><code>PROT_READ</code>：可以被读取。</li><li><code>PROT_WRITE</code>：可以被写入。</li><li><code>PROT_NONE</code>：不可访问。</li></ul></li><li><p><code>flags</code>：指定映射的类型，常用的可选值如下：</p></li><li><ul><li><code>MAP_FIXED</code>：使用指定的起始虚拟内存地址进行映射。</li><li><code>MAP_SHARED</code>：与其它所有映射到这个文件的进程共享映射空间（可实现共享内存）。</li><li><code>MAP_PRIVATE</code>：建立一个写时复制（Copy on Write）的私有映射空间。</li><li><code>MAP_LOCKED</code>：锁定映射区的页面，从而防止页面被交换出内存。</li><li>...</li></ul></li><li><p><code>fd</code>：进行映射的文件句柄。</p></li><li><p><code>offset</code>：文件偏移量（从文件的何处开始映射）。</p></li></ul><p>介绍完 <code>mmap</code> 函数的原型后，我们现在通过一个简单的例子介绍怎么使用 <code>mmap</code>：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>filepath<span class="token punctuation">,</span> O_RDWR<span class="token punctuation">,</span> <span class="token number">0644</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                           <span class="token comment">// 打开文件</span>
<span class="token keyword">void</span> <span class="token operator">*</span>addr <span class="token operator">=</span> <span class="token function">mmap</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">8192</span><span class="token punctuation">,</span> PROT_WRITE<span class="token punctuation">,</span> MAP_SHARED<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token number">4096</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 对文件进行映射</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面例子中，我们先通过 <code>open</code> 函数以可读写的方式打开文件，然后通过 <code>mmap</code> 函数对文件进行映射，映射的方式如下：</p><ul><li><code>addr</code> 参数设置为 NULL，表示让操作系统自动选择合适的虚拟内存地址进行映射。</li><li><code>length</code> 参数设置为 8192 表示映射的区域为 2 个内存页的大小（一个内存页的大小为 4 KB）。</li><li><code>prot</code> 参数设置为 <code>PROT_WRITE</code> 表示映射的内存区为可读写。</li><li><code>flags</code> 参数设置为 <code>MAP_SHARED</code> 表示共享映射区。</li><li><code>fd</code> 参数设置打开的文件句柄。</li><li><code>offset</code> 参数设置为 4096 表示从文件的 4096 处开始映射。</li></ul></blockquote><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/81d58e6a60dc50dc9cffa91bf6ec9113.png" alt="image-20231123160342823" style="zoom:67%;"><p>利用这一点，我们就无需将内核缓冲区的数据拷贝到用户缓冲区，直接在用户缓冲区操作，就相当于在内核缓冲区（Page Cache）上操作。</p><p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/a54249d1d17fe835b279af9a062247a8.png" alt="" loading="lazy"></p><p>现在涉及到了<strong>一次CPU拷贝，四次上下文切换</strong>。并且用户进程内存是<strong>虚拟的</strong>，只是<strong>映射</strong>到内核的读缓冲区，可以节省一半的内存空间。</p><h3 id="sendfile" tabindex="-1"><a class="header-anchor" href="#sendfile" aria-hidden="true">#</a> sendfile</h3><p>我们知道<strong>上下文切换</strong>也是非常耗时的，CPU需要保存当前线程的状态上下文，并且还原要执行线程的状态上下文。但也是不可或缺的，因为些特殊操作，如磁盘文件读写、内存的读写等等。因为这些都是比较危险的操作，<strong>不可以由应用程序乱来</strong>，只能交给底层操作系统来，需要程序陷入内核态，才可以执行特权操作，我们现在涉及到了两次陷入内核，相当于四次切换上下文，还需要想办法优化。</p><p><code>sendfile</code>是Linux2.1内核版本后引入的一个系统调用函数，API如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token class-name">ssize_t</span> <span class="token function">sendfile</span><span class="token punctuation">(</span><span class="token keyword">int</span> out_fd<span class="token punctuation">,</span> <span class="token keyword">int</span> in_fd<span class="token punctuation">,</span> <span class="token class-name">off_t</span> <span class="token operator">*</span>offset<span class="token punctuation">,</span> <span class="token class-name">size_t</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>out_fd:为待写入内容的文件描述符，一个socket描述符。</li><li>in_fd:为待读出内容的文件描述符，必须是真实的文件，不能是socket和管道。</li><li>offset：指定从读入文件的哪个位置开始读，如果为NULL，表示文件的默认起始位置。</li><li>count：指定在fdout和fdin之间传输的字节数。</li></ul><p>sendfile表示在两个文件描述符之间传输数据，它是在<strong>操作系统内核</strong>中操作的，<strong>避免了数据从内核缓冲区和用户缓冲区之间的拷贝操作</strong>，因此可以使用它来实现零拷贝。</p><p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/f5f752dbe4a6cce7bf649e5ff9072cc2.png" alt="" loading="lazy"></p><p>现在涉及到了<strong>一次CPU拷贝，两次上下文切换</strong>。人总是贪婪的，能不能不要CPU原地打滚，直接使用现成的数据呢？</p><h3 id="sendfile-dma拷贝" tabindex="-1"><a class="header-anchor" href="#sendfile-dma拷贝" aria-hidden="true">#</a> sendfile+DMA拷贝</h3><p>Linux 2.4 内核对 sendfile 系统调用进行优化，但是需要硬件DMA控制器的配合。引入SG-DMA技术，其实就是对DMA拷贝加入了<code>scatter/gather</code>操作，它可以直接从内核空间缓冲区中将数据读取到网卡。</p><p>升级后的sendfile将内核空间缓冲区中对应的数据描述信息（文件描述符、地址偏移量等信息）记录到socket缓冲区中。</p><p>DMA控制器根据socket缓冲区中的地址和偏移量将数据从内核缓冲区拷贝到网卡中，从而省去了内核空间中仅剩1次CPU拷贝。</p><p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/b4723edde520f73d0ab9e1683c77e8d9.png" alt="" loading="lazy"></p><p>最后只剩下了<strong>两次上下文切换</strong>。</p>`,22);function v(P,z){const a=c("ExternalLinkIcon");return p(),l("div",null,[d,n("p",null,[n("a",r,[s("【linux】图文并茂|彻底搞懂零拷贝（Zero-Copy）技术 - 知乎 (zhihu.com)"),e(a)])]),n("p",null,[n("a",u,[s("看一遍就理解：零拷贝原理详解 - 知乎 (zhihu.com)"),e(a)])]),g,m,h,f,n("p",null,[n("a",k,[s("Linux内核黑科技——mmap实现详解 - 知乎 (zhihu.com)"),e(a)])]),n("p",null,[n("a",_,[s("一文读懂 mmap 原理 - 知乎 (zhihu.com)"),e(a)])]),b])}const A=t(i,[["render",v],["__file","零拷贝.html.vue"]]);export{A as default};
