import{_ as t,r as p,o,c,a as n,b as s,d as e,e as l}from"./app-20538318.js";const i={},r=l(`<p>本文介绍生成分布式id的一种方法，雪花算法。</p><h2 id="雪花算法" tabindex="-1"><a class="header-anchor" href="#雪花算法" aria-hidden="true">#</a> 雪花算法</h2><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/67234308acfba9be7f6c295c1599b1c3.png" style="zoom:67%;"><p>序列号保证了在高并发的情况下可以生成不重复的id。</p><p>时间戳保证了雪花算法生成的id是趋势递增的，很大程度上保证了B+树索引插入的性能，适合于做主键。</p><h2 id="机器id分配" tabindex="-1"><a class="header-anchor" href="#机器id分配" aria-hidden="true">#</a> 机器ID分配</h2><p>首先是如何对数据中心id和工作机器id进行区分。</p><p>mp的做法是采用MAC地址以及进程的PID，但是这样也有可能重复，因为对于10位的数字，取余是无法避免哈希冲突的，尽管概率很小。</p><p>下面是两种解决方案：</p><h3 id="预分配" tabindex="-1"><a class="header-anchor" href="#预分配" aria-hidden="true">#</a> 预分配</h3><p>人工分配，缺点是无法扩容。</p><h3 id="动态分配" tabindex="-1"><a class="header-anchor" href="#动态分配" aria-hidden="true">#</a> 动态分配</h3><p>将id放入中间件中，服务启动时去中间件中请求，通常采用redis+lua的方式。</p><p>redis维护hash结构，放入两个key：datacenterId，workId。</p><div class="language-lua line-numbers-mode" data-ext="lua"><pre class="language-lua"><code><span class="token keyword">local</span> hashKey <span class="token operator">=</span> <span class="token string">&#39;snowflake_work_id_key&#39;</span>
<span class="token keyword">local</span> dataCenterIdKey <span class="token operator">=</span> <span class="token string">&#39;dataCenterId&#39;</span>
<span class="token keyword">local</span> workIdKey <span class="token operator">=</span> <span class="token string">&#39;workId&#39;</span>

<span class="token comment">-- 如果当前hash不存在，则初始化</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;exists&#39;</span><span class="token punctuation">,</span> hashKey<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">then</span>
    redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;hincrby&#39;</span><span class="token punctuation">,</span> hashKey<span class="token punctuation">,</span> dataCenterIdKey<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
    redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;hincrby&#39;</span><span class="token punctuation">,</span> hashKey<span class="token punctuation">,</span> workIdKey<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">}</span>
<span class="token keyword">end</span>
<span class="token comment">-- 获取当前dataCenterId和workId</span>
<span class="token keyword">local</span> dataCenterId <span class="token operator">=</span> <span class="token function">tonumber</span><span class="token punctuation">(</span>redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;hget&#39;</span><span class="token punctuation">,</span> hashKey<span class="token punctuation">,</span> dataCenterIdKey<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">local</span> workId <span class="token operator">=</span> <span class="token function">tonumber</span><span class="token punctuation">(</span>redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;hget&#39;</span><span class="token punctuation">,</span> hashKey<span class="token punctuation">,</span> workIdKey<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">local</span> max <span class="token operator">=</span> <span class="token number">31</span>
<span class="token keyword">local</span> resultWorkId <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">local</span> resultDataCenterId <span class="token operator">=</span> <span class="token number">0</span>

<span class="token comment">-- 如果当前dataCenterId和workId都是最大值，则重置为0</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>dataCenterId <span class="token operator">==</span> max <span class="token keyword">and</span> workId <span class="token operator">==</span> max<span class="token punctuation">)</span> <span class="token keyword">then</span>
    redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;hset&#39;</span><span class="token punctuation">,</span> hashKey<span class="token punctuation">,</span> dataCenterIdKey<span class="token punctuation">,</span> <span class="token string">&#39;0&#39;</span><span class="token punctuation">)</span>
    redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;hset&#39;</span><span class="token punctuation">,</span> hashKey<span class="token punctuation">,</span> workIdKey<span class="token punctuation">,</span> <span class="token string">&#39;0&#39;</span><span class="token punctuation">)</span>
<span class="token comment">-- 先去获取workId，如果workId不是最大值，则workId+1，dataCenterId不变</span>
<span class="token keyword">elseif</span> <span class="token punctuation">(</span>workId <span class="token operator">~=</span> max<span class="token punctuation">)</span> <span class="token keyword">then</span>
    resultWorkId <span class="token operator">=</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;hincrby&#39;</span><span class="token punctuation">,</span> hashKey<span class="token punctuation">,</span> workIdKey<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
    resultDataCenterId <span class="token operator">=</span> dataCenterId
<span class="token comment">-- 如果当前dataCenterId不是最大值，workId为最大值，则workId重置为0，dataCenterId+1</span>
<span class="token keyword">elseif</span> <span class="token punctuation">(</span>dataCenterId <span class="token operator">~=</span> max<span class="token punctuation">)</span> <span class="token keyword">then</span>
    resultWorkId <span class="token operator">=</span> <span class="token number">0</span>
    resultDataCenterId <span class="token operator">=</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;hincrby&#39;</span><span class="token punctuation">,</span> hashKey<span class="token punctuation">,</span> dataCenterIdKey<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
    redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;hset&#39;</span><span class="token punctuation">,</span> hashKey<span class="token punctuation">,</span> workIdKey<span class="token punctuation">,</span> <span class="token string">&#39;0&#39;</span><span class="token punctuation">)</span>
<span class="token keyword">end</span>

<span class="token keyword">return</span> <span class="token punctuation">{</span> resultWorkId<span class="token punctuation">,</span> resultDataCenterId <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在1024节点下可以保证服务id唯一。</p><h2 id="问题" tabindex="-1"><a class="header-anchor" href="#问题" aria-hidden="true">#</a> 问题</h2><h3 id="时钟回拨" tabindex="-1"><a class="header-anchor" href="#时钟回拨" aria-hidden="true">#</a> 时钟回拨</h3><p>如果机器的时钟回拨，则生成的id可能会重复（人工调整，NTP调整）。</p><p>设置容忍范围，如果大于容忍范围需要直接抛出异常，结束流程。</p><h3 id="序列号不够用" tabindex="-1"><a class="header-anchor" href="#序列号不够用" aria-hidden="true">#</a> 序列号不够用</h3><p>序列号是用于解决毫秒级并发的问题，如果lastTimestamp等于当前的timestamp，说明发生了毫秒级并发。我们就需要使用计数器进行自增。</p><p>如果并发超过了4096，对于新到的请求，我们就必须停止生成id，等到下一毫秒，注意这里不需要加锁，循环获取当前时间戳即可。</p><p>毫秒级并发超过4096，那么单台机器TPS就到达了四百万，对于大部分实际场景都够用了。</p><h3 id="机器id不够用" tabindex="-1"><a class="header-anchor" href="#机器id不够用" aria-hidden="true">#</a> 机器ID不够用</h3><p>如果机器ID不够分配，我们只能从ID的划分下手。</p><p>一是时间戳，我们如果减少一位，时间戳的可用年数就减少到35年左右，是否要减少时间戳这个需要自己衡量。</p><p>二是序列号，如果减少序列号，单台机器的TPS的最大值就会减少，但是集群的TPS逻辑上是不变的，因为机器增多了，做好负载均衡就行。</p><h3 id="性能" tabindex="-1"><a class="header-anchor" href="#性能" aria-hidden="true">#</a> 性能</h3>`,29),d=n("code",null,"System.currentTimeMillis()",-1),u={href:"https://apidoc.gitee.com/dromara/hutool/cn/hutool/core/date/SystemClock.html",target:"_blank",rel:"noopener noreferrer"},k={href:"https://blog.csdn.net/qq_30062181/article/details/108681101",target:"_blank",rel:"noopener noreferrer"},h=n("h2",{id:"分库分表",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#分库分表","aria-hidden":"true"},"#"),s(" 分库分表")],-1),m={href:"https://www.jianshu.com/p/f415d0d2dac2",target:"_blank",rel:"noopener noreferrer"},v={href:"https://juejin.cn/post/6964028801626046471",target:"_blank",rel:"noopener noreferrer"},b=n("p",null,"和基因法结合，假设取4位，将最后的序列号去掉四位和基因数字融合，然后再按照最后四位进行分库分表。可以使得相同基因的记录分在相同的库/表中。",-1);function y(I,f){const a=p("ExternalLinkIcon");return o(),c("div",null,[r,n("p",null,[s("在实际代码中，Java会涉及到取当前的毫秒时间戳的操作"),d,s("，这是极其耗时的。调用的是native方法，会陷入内核态，当多个线程同时请求时还会加大竞争，结果也不稳定。所以在这里引入了单例模式，由于雪花算法的时间戳是毫秒级，所以在同一毫秒内的时间戳相同，就可以将其缓存起来，hutool的"),n("a",u,[s("SystemClock"),e(a)]),s("是一个不错的选择。")]),n("p",null,[n("a",k,[s("高并发下System.currentTimeMillis()竟然有这么大的问题"),e(a)])]),h,n("p",null,[n("a",m,[s("数据库横向分表（基因法）"),e(a)]),s("，"),n("a",v,[s("基因算法-分库分表的超级解决方案 "),e(a)])]),b])}const _=t(i,[["render",y],["__file","snowflakeid.html.vue"]]);export{_ as default};
