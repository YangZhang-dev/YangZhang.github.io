import{_ as s,o as n,c as e,e as a}from"./app-20538318.js";const c={},i=a(`<p>在看王道计组指令系统时，学到了很多关于汇编的知识，正好和当时的CSAPP结合起来，但是总感觉少点实战记忆的不清楚，故准备用GDB调试一下，以函数调用为例子，将这边的知识过一遍。</p><p>操作系统：<code>Ubuntu 20.04.4 LTS x86_64</code></p><p>GCC：<code>9.4.0</code></p><h2 id="寄存器" tabindex="-1"><a class="header-anchor" href="#寄存器" aria-hidden="true">#</a> 寄存器</h2><p>在具体到代码之前，我们需要先了解一下常用的寄存器。</p><p>在调用关系中，假设P调用Q，我们将P称为调用者，Q为被调用者。由于寄存器在函数调用中是共享的，为了保护现场，我们需要对寄存器进行保护，具体分为：</p><ul><li><p>被调用者保护寄存器</p><p>由被调用者负责保存的寄存器，此类寄存器通常有着比较特殊的作用，如<code>rbp</code>存储当前栈帧的起始地址，<code>rbx</code>存储程序基地址。常有<code>rbp rbx r12~r15</code>。</p></li><li><p>调用者保护寄存器</p><p>此类寄存器常常由调用者保护，更加通用，如函数返回用的是<code>rax</code>，故每个函数的<code>rax</code>寄存器就需要自己进行保护。常有<code>rax rcx rdx rsi rdi r8~r11</code></p></li></ul><p>此外，<code>rsp</code>为栈指针寄存器，保存当前栈的栈顶，<code>rip</code>的作用类似于pc，指向下一条指令的地址。</p><h2 id="完整栈帧实例" tabindex="-1"><a class="header-anchor" href="#完整栈帧实例" aria-hidden="true">#</a> 完整栈帧实例</h2><p>以下是根据王道课上的导图结合x86画出的一个完整的栈帧，可以先有个印象</p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/379ec47956d0d334099cfc50547385cc.png" style="zoom:80%;"><h2 id="函数调用流程" tabindex="-1"><a class="header-anchor" href="#函数调用流程" aria-hidden="true">#</a> 函数调用流程</h2><p>下面，我们以一个实际的例子来讲解，函数调用是怎么在栈和寄存器的配合下完成的。</p><h3 id="代码准备" tabindex="-1"><a class="header-anchor" href="#代码准备" aria-hidden="true">#</a> 代码准备</h3><p>首先我们写出以下源代码：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">,</span> <span class="token keyword">int</span> d<span class="token punctuation">,</span> <span class="token keyword">int</span> f<span class="token punctuation">,</span> <span class="token keyword">int</span> g<span class="token punctuation">,</span><span class="token keyword">int</span> h<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>  
        <span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        s <span class="token operator">+=</span> i<span class="token punctuation">;</span>
        <span class="token keyword">return</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        result <span class="token operator">+=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先解释一下为什么在<code>test</code>中定义七个参数，在64位下，前六个参数是由寄存器传递的，如果我们要看栈传参，就需要定义七个参数。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>gcc <span class="token parameter variable">-g</span> <span class="token parameter variable">-o</span> hello hello.c

objdump <span class="token parameter variable">-s</span> <span class="token parameter variable">-d</span> <span class="token parameter variable">-M</span> intel hello <span class="token operator">&gt;</span> hello.s
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>得到以下的汇编代码（-M intel 获得intel分割的代码，默认AT&amp;T）：</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>0000000000001129 &lt;test&gt;:
    1129:	f3 0f 1e fa          	endbr64 
    112d:	55                   	push   %rbp
    112e:	48 89 e5             	mov    %rsp,%rbp
    1131:	89 7d fc             	mov    %edi,-0x4(%rbp)
    1134:	89 75 f8             	mov    %esi,-0x8(%rbp)
    1137:	89 55 f4             	mov    %edx,-0xc(%rbp)
    113a:	89 4d f0             	mov    %ecx,-0x10(%rbp)
    113d:	44 89 45 ec          	mov    %r8d,-0x14(%rbp)
    1141:	44 89 4d e8          	mov    %r9d,-0x18(%rbp)
    1145:	8b 55 fc             	mov    -0x4(%rbp),%edx
    1148:	8b 45 f8             	mov    -0x8(%rbp),%eax
    114b:	01 d0                	add    %edx,%eax
    114d:	5d                   	pop    %rbp
    114e:	c3                   	retq   

000000000000114f &lt;func&gt;:
    114f:	f3 0f 1e fa          	endbr64 
    1153:	55                   	push   %rbp
    1154:	48 89 e5             	mov    %rsp,%rbp
    1157:	48 83 ec 18          	sub    $0x18,%rsp
    115b:	89 7d ec             	mov    %edi,-0x14(%rbp)
    115e:	c7 45 f8 05 00 00 00 	movl   $0x5,-0x8(%rbp)
    1165:	6a 07                	pushq  $0x7
    1167:	41 b9 06 00 00 00    	mov    $0x6,%r9d
    116d:	41 b8 05 00 00 00    	mov    $0x5,%r8d
    1173:	b9 04 00 00 00       	mov    $0x4,%ecx
    1178:	ba 03 00 00 00       	mov    $0x3,%edx
    117d:	be 02 00 00 00       	mov    $0x2,%esi
    1182:	bf 01 00 00 00       	mov    $0x1,%edi
    1187:	e8 9d ff ff ff       	callq  1129 &lt;test&gt;
    118c:	48 83 c4 08          	add    $0x8,%rsp
    1190:	89 45 fc             	mov    %eax,-0x4(%rbp)
    1193:	8b 45 f8             	mov    -0x8(%rbp),%eax
    1196:	01 45 fc             	add    %eax,-0x4(%rbp)
    1199:	8b 45 fc             	mov    -0x4(%rbp),%eax
    119c:	c9                   	leaveq 
    119d:	c3                   	retq   

000000000000119e &lt;main&gt;:
    119e:	f3 0f 1e fa          	endbr64 
    11a2:	55                   	push   %rbp
    11a3:	48 89 e5             	mov    %rsp,%rbp
    11a6:	48 83 ec 10          	sub    $0x10,%rsp
    11aa:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%rbp)
    11b1:	bf 0a 00 00 00       	mov    $0xa,%edi
    11b6:	e8 94 ff ff ff       	callq  114f &lt;func&gt;
    11bb:	01 45 fc             	add    %eax,-0x4(%rbp)
    11be:	b8 00 00 00 00       	mov    $0x0,%eax
    11c3:	c9                   	leaveq 
    11c4:	c3                   	retq   
    11c5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    11cc:	00 00 00 
    11cf:	90                   	nop
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="main" tabindex="-1"><a class="header-anchor" href="#main" aria-hidden="true">#</a> main</h3><p>下面通过GDB一遍调试，一边过一遍函数调用的流程</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>gdb hello
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们先在三个函数中的关键地方打上断点：</p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/811c4641cddda98e81d437a70ed38ddf.png" alt="image-20240615171913761" style="zoom:50%;"><p>键入<code>run</code>就会运行，停止在第一个断点。</p><p>这时，我们输入<code>disassemble</code>就可以看到当前函数的反汇编代码以及指令地址：</p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/b8548c32e6bdcb96ef41cf3974ab45f0.png" alt="image-20240615172120034" style="zoom:50%;"><p>从图中看出<code>rbp-4</code>应该是<code>result</code>的地址。</p><p>我们输入<code>info registers rsp rbp rip</code> 来看一下三个重要的寄存器值：</p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/995bc7a2550f5f2c9735f415f348ae94.png" alt="image-20240615172334899" style="zoom:50%;"><ul><li><code>rip</code>的值正是下一条指令（<code>0x00005555555551b1</code>还没有执行）</li><li><code>rsp</code>指向栈顶，<code>rsp</code>指向当前栈帧的底部，注意栈是由高地址向低地址增长</li></ul><p>我们知道<code>int</code>占用4个字节，同时根据栈帧图，我们得出局部变量<code>result</code>位于<code>rbp-4=0x7fffffffde4C</code>。这时，输入<code>x/1xw 0x7fffffffde4C</code>，用处是以十六进制方式，四个字节为单位，查看位于<code>0x7fffffffde4C</code>的一个单位的内存值。</p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/5f9e676c2b0a059953ab1316f9261abc.png" alt="image-20240615175144957" style="zoom:67%;"><p>验证了我们的栈帧图中关于局部变量的部分。</p><h3 id="func" tabindex="-1"><a class="header-anchor" href="#func" aria-hidden="true">#</a> func</h3><p>接下来输入<code>s</code>逐步调试，进入func函数</p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/c33701cd21a4ee1cc6aa4bbbc70fd9fb.png" alt="image-20240615180330862" style="zoom:50%;"><p>这时我们可以输入<code>bt</code>查看以下当前的栈，发现当前栈中已经压入了两个栈帧</p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/57a865083a935f52c2ed81479704190f.png" alt="image-20240615180416402" style="zoom:50%;"><p>看一下反汇编代码：</p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/f340286f51db633ef604d43edeafe8a4.png" alt="image-20240615180657077" style="zoom:50%;"><p>再次查看三个寄存器的值：</p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/f18c0be9428ce1d023d94255c03b939d.png" alt="image-20240615180553343" style="zoom:50%;"><ul><li><code>rip</code>的值改为了<code>func</code>的首条指令</li><li><code>rbp</code>还没有改动，需要等到<code>&lt;+4&gt; &lt;+5&gt;</code>时才会将其压栈，同时<code>rsp</code>增长了八个字节</li></ul><p>我们输入<code>x/1hg 0x7fffffffde38</code>查看一下刚刚压入栈中的值，发现正是我们在<code>main</code>函数中<code>call</code>指令的下一条指令的地址。</p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/932d2f3a84f87d8cdb03b5ac6b058a81.png" alt="image-20240615181100312" style="zoom:50%;"><p>这样就验证了关于<code>call</code>指令的作用。</p><p>继续单步调试，发现执行了</p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/cdb24d055bada976d404ab97936d0435.png" alt="image-20240615182159188" style="zoom:50%;"><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/d9712855d7c4f98030225b224e9d0521.png" alt="image-20240615185541242" style="zoom:50%;"><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>push %rbp               ; 将main函数的栈帧及地址压入栈中
mov %rsp,%rbp           ; 将rbp指向rsp指向的位置
sub    $0x18,%rsp       ; 扩栈，扩充24个字节
mov    %edi,-0x14(%rbp) ; 从%edi中获取第一个参数，放到刚刚扩充的倒数第二个位置
movl   $0x5,-0x8(%rbp)  ; 将局部变量i放在正数第二个位置
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>第一步和第二部实际上就是被调用者保存寄存器的保存步骤，将旧的ebp保存起来，同时扩栈</li><li>后面是对参数和局部变量的初始化</li></ul><p>我们可以看一下内存布局</p><p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/76cb4df33bbb3eab61104f1cf3ffa3ee.png" alt="image-20240615183507806" loading="lazy"></p><p>我们再看接下来的代码：</p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/aaba4f4f1750908fb6042fdf1e677115.png" alt="image-20240615184017035" style="zoom:50%;"><p>明显前六个参数使用的寄存器传参，而最后一个参数是栈传参。</p><p>我们接着向下单步调试。</p><h3 id="test" tabindex="-1"><a class="header-anchor" href="#test" aria-hidden="true">#</a> test</h3><p>进入<code>test</code>中，还是先看三个寄存器：</p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/2a22e0721e873cf48c782c81ea04cadd.png" alt="image-20240615184256821" style="zoom:50%;"><p>还是先看一下刚刚压入栈的值：</p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/bde155cd10d0fc9ecf10b9f75ce63eba.png" alt="image-20240615185804977" style="zoom:67%;"><p>正是<code>func</code>的下一条指令，接着我们主要看一下函数参数的获取</p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/5436272ae62e87a1d20ded891ba8fbeb.png" alt="image-20240615185927649" style="zoom:50%;"><p>我们发现<code>%edi</code>中的第一个参数放入到了<code>-0x4(%rbp)</code>中，后面的依次压栈，符合我们的栈帧图。</p><p>当前这个例子没有体现出获取栈参数，故我又改了一下代码，就是在test中改为<code>return a + b + h;</code></p><p>再次GDB，可以看到</p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/a40f8bcb2cb22223f52b400abcb0cfe3.png" alt="image-20240615192802036" style="zoom:50%;"><p>这次我们在获取前六个参数，并将前两个参数相加后，尝试从rbp加16个字节的位置获取栈参数，我们简单的计算发现就是<code>旧的rbp</code>以及<code>返回rip</code>，加起来正是<code>0x10</code>.我们也可以看一下内存布局</p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/08197f6f887c8d7f8d2272e56565a5a0.png" alt="image-20240615193007240" style="zoom:50%;"><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/f226da1e14049b2165e44dbf0286dc6b.png" alt="image-20240615192951412" style="zoom:50%;"><p>从格式上不难看出，第一个正是<code>旧的rbp</code>，第二个是<code>旧的rip</code>（由于新运行的GDB，故值可能不连贯）。而第三个则是我们的栈传入参数。</p><p>现在，我们回到第一次运行的GDB，看看函数返回是怎样的。（<code>si</code> 单步汇编指令调试）</p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/99d1eb3d26aafe5996913b3ca4fb370c.png" alt="image-20240615193357534" style="zoom:50%;"><p>我们知道函数是通过<code>%eax</code>返回的，我们查看一下<code>%eax</code>的值确实为应有的值：3</p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/61b56663eb731b5a2bf650bb711f0043.png" alt="image-20240615193459291" style="zoom:50%;"><p>然后经过 <code>pop %rbp</code> 后，我们的栈帧被释放，<code>rbp</code>指向上一层栈帧的对应<code>rbp</code>位置</p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/5dd29817c9bb49bb98782b9f4a54af87.png" alt="image-20240615193705073" style="zoom:50%;"><p>至此结束。</p><h3 id="一些问题" tabindex="-1"><a class="header-anchor" href="#一些问题" aria-hidden="true">#</a> 一些问题</h3><p>我们会发现在<code>test</code>函数中，并没有像<code>func</code>一样使用<code>sub $0x18,%rsp</code>扩栈，返回也没有使用<code>leave</code>指令，也就是说其没有栈帧，在函数周期中，其<code>rsp</code>和<code>rbp</code>一直处于相等的状态，这可能是一种优化，目前我也没有搞清楚。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>通过这一次的实际调试，感觉对书上的知识有了更深刻的理解，同时也简单的入门了GCC。</p><p>纸上得来终觉浅，绝知此事要躬行。</p>`,86),t=[i];function d(l,o){return n(),e("div",null,t)}const r=s(c,[["render",d],["__file","汇编下的函数调用.html.vue"]]);export{r as default};
