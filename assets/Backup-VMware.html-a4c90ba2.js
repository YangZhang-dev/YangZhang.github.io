import{_ as s,r as t,o as c,c as o,a,b as e,d as r,w as h,e as n}from"./app-20538318.js";const p={},d=n('<p>本节主要讲的是主从复制之间的细节以及VMware如何做的。</p><h2 id="backup" tabindex="-1"><a class="header-anchor" href="#backup" aria-hidden="true">#</a> Backup</h2><p>为了提高系统的容错能力，通常会采用主从复制的技术，即有两个或多个机器，分出主从，维护它们之间的状态同一，当主服务器出现崩溃时，可以再次选取一个从服务器代替。（同时可以通过这一特点做读写分离，不过要考虑一致性的问题）。</p><h3 id="复制失败场景" tabindex="-1"><a class="header-anchor" href="#复制失败场景" aria-hidden="true">#</a> 复制失败场景</h3><ul><li>fail-stop failure：计算机停止工作：断电，地震等。</li><li>logic bugs：复制逻辑问题或配置异常，无法通过系统自动恢复。</li><li>malicious errors：在这里假设所有的机器都是可信的，没有对伪造者进行判别。</li></ul><p>在这里只通过复制技术处理第一种的失败情况。</p><h3 id="难点" tabindex="-1"><a class="header-anchor" href="#难点" aria-hidden="true">#</a> 难点</h3><ul><li>如何判断primary失败？ <ul><li>无法区分是网络分区还是机器故障。</li><li>如果是网络分区，primary有可能还在和client交流。在这时如果又选出一个primary，就会出现<strong>脑裂</strong>（split-brain）场景，这样数据的一致性就无法得到保证，服务器之间就会出现状态的各种不一致。</li></ul></li><li>如何主从同步： <ul><li>保证所有操作按照正确的顺序被处理。</li><li>避免或解决非决定论（如获取当前时间）。</li></ul></li><li>故障转移：希望在进行主备切换时，能够使primary完成自己的client响应。</li></ul><h3 id="主备复制" tabindex="-1"><a class="header-anchor" href="#主备复制" aria-hidden="true">#</a> 主备复制</h3><p>有两种主备复制选项：</p><ul><li><strong>状态转移</strong>（state transfer）：在primary响应client之前，将checkpoint同步到backup上。</li><li><strong>复制状态机</strong>（replicated state machine，RSM）：和上面的类似，只是同步的不再是状态，而是操作。</li></ul><p>通常采用第二种，第一种有可能产生多种状态，增大网络消耗。</p><blockquote><p>不可以直接将client发至backup上：因为对于不确定的操作，两个机器会产生不一样的结果。而对于复制状态机方案，由分布式系统内部设计解决该问题。</p></blockquote><h3 id="复制操作级别" tabindex="-1"><a class="header-anchor" href="#复制操作级别" aria-hidden="true">#</a> 复制操作级别</h3><ul><li>application-level-operations：即在主从之间传递应用层面的消息。</li><li>machine-level-operations：即传递的是机器级别的指令。</li></ul><h2 id="vm-ft" tabindex="-1"><a class="header-anchor" href="#vm-ft" aria-hidden="true">#</a> VM-FT</h2><p>虚拟化复制对应用程序透明，能够提供很强的一致性（可以见得它的性能应该不咋地）。</p><img src="https://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/ce9a032c6337e31a8be574a501768b0d.png" style="zoom:80%;"><h3 id="组成部分" tabindex="-1"><a class="header-anchor" href="#组成部分" aria-hidden="true">#</a> 组成部分</h3><h4 id="hypervisor" tabindex="-1"><a class="header-anchor" href="#hypervisor" aria-hidden="true">#</a> hypervisor</h4><p>虚拟监视器，当硬件产生中断（网络包，定时器）时会对中断进行捕捉处理。</p><p>对于数据包到达中断，primary会将其通过log channel将其传递给backup，对于无状态的应用程序，使用确定性的指令，并输入相同的输出，最后的结果是相同的。这样就保证了数据的一致性。</p><p>当backup接收到消息后，会立即返回ack，然后backup的hypervisor将数据包传递给backup的VM，然而当backup的程序运行完毕后向虚拟网卡发送数据包时，hypervisor会判断自己是backup，就不会将数据包传递给物理网卡。</p><p>当primary处理完毕后，必须等到backup的ack后才能对client做出响应，这被称为<strong>输出规则</strong>（output rule）。一旦backup成功收到信息，崩溃之后就可以通过checkpoint保障数据一致性。</p><h4 id="server" tabindex="-1"><a class="header-anchor" href="#server" aria-hidden="true">#</a> server</h4>',25),u=n('<ul><li>系统初始化时。</li><li>primary故障，多backup竞争时，手动设置为0。</li></ul><h4 id="log-channel" tabindex="-1"><a class="header-anchor" href="#log-channel" aria-hidden="true">#</a> log channel</h4><p>log channel是最为重要的组件，在保证数据的一致性时，就使用到了log channel。</p><p>假设在运行的应用程序的指令都是确定含义的状态下，它可以工作的很好，但是对于非确定性含义的指令，会带来灾难。对于获取当前时间指令，主从不可能做到完全一致，这样就可能影响到一致性的保证。</p><p>同时，两台不同的主机，时钟中断也是不同的，同样会造成状态不一致。</p><h4 id="disk" tabindex="-1"><a class="header-anchor" href="#disk" aria-hidden="true">#</a> disk</h4><p>在论文中，disk的设计分为两种：</p><ul><li>主从共用：实际上只有primary进行写入。</li><li>主从分离：各自写入，但是在初始化阶段需要同步disk。</li></ul><h3 id="差异来源" tabindex="-1"><a class="header-anchor" href="#差异来源" aria-hidden="true">#</a> 差异来源</h3><ul><li>网络包中断，定时器中断</li><li>非确定性的指令</li><li>多核：对于多线程的资源争夺，不同的计算机的结果可能是不同的，VM-FT只是简单的禁用了多核。</li></ul><h3 id="处理中断" tabindex="-1"><a class="header-anchor" href="#处理中断" aria-hidden="true">#</a> 处理中断</h3>',11),b={href:"https://ashiamd.github.io/docsify-notes/#/study/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AD%96%E7%95%A5/MIT6.824%E7%BD%91%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01",target:"_blank",rel:"noopener noreferrer"},k=a("p",null,"这里VM-FT是这样处理的，当接受到中断时，VM-FT能知道CPU已经执行了多少指令（比如执行了100条指令），并且计算一个位置（比如100），告知backup之后在指令执行到第100条的时候，执行中断处理程序。大多数处理器（比如x86）支持在执行到第X条指令后停止，然后将控制权返还给操作系统（这里即虚拟机监视器）。",-1),m=a("p",null,"通过上面的流程，VM-FT能保证primary和backup按照相同的指令流顺序执行。当然，这里backup会落后一条message（因为primary总是领先backup执行完需要在logging channel上传递的消息）。",-1),_=a("h3",{id:"处理非确定性指令",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#处理非确定性指令","aria-hidden":"true"},"#"),e(" 处理非确定性指令")],-1),f={href:"https://ashiamd.github.io/docsify-notes/#/study/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AD%96%E7%95%A5/MIT6.824%E7%BD%91%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01",target:"_blank",rel:"noopener noreferrer"},y=a("p",null,"在启动Guest space中的Linux之前（boot），先扫描Linux中所有的非确定性指令，确保把它们转为无效指令(invalid instruction)。",-1),E=a("p",null,"当Guest space中的Linux执行这些非确定性的指令时，它将控制权通过trap交给hypervisor，此时hypervisor通过导致trap的原因能知道guest在执行非确定的指令，它会模拟这条指令的执行效果，然后记录指令模拟执行后的结果，比如记录到寄存器a0中，值为221。",-1),g=a("p",null,"而backup备机上的Linux在后续某个时间点也会执行这条非确定性指令，然后通过trap进入backup的hypervisor，通常backup的hypervisor会等待，直到primary将这条指令模拟执行后的结果同步给自己(backup)，然后backup就能和primary在这条非确定性指令执行上拥有一致的结果。",-1),x={href:"http://nil.csail.mit.edu/6.824/2021/papers/vm-ft.pdf",target:"_blank",rel:"noopener noreferrer"};function v(B,A){const l=t("RouterLink"),i=t("ExternalLinkIcon");return c(),o("div",null,[d,a("p",null,[e("在仲裁服务器中，用于存储和判断谁是primary。flag初始化为0，当多台服务器竞争primary时，用到了"),r(l,{to:"/code/basic/ostep/ostep-concurrency.html#%E7%A1%AC%E4%BB%B6%E5%8E%9F%E8%AF%AD"},{default:h(()=>[e("test-and-set")]),_:1}),e("来进行选举primary。何时设置为0：")]),u,a("p",null,[e("出处："),a("a",b,[e("参考笔记"),r(i)])]),k,m,_,a("p",null,[e("出处："),a("a",f,[e("参考笔记"),r(i)])]),y,E,g,a("p",null,[e("VM-FT paper："),a("a",x,[e("The design of a practical system for fault-tolerant virtual machines (mit.edu)"),r(i)]),e("。")])])}const M=s(p,[["render",v],["__file","Backup-VMware.html.vue"]]);export{M as default};
